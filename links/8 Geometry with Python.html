<!DOCTYPE html>
<!-- saved from url=(0071)https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>8 Geometry with Python</title>
  <meta name="description" content="">

  <!-- OpenGraph for Facebook, Twitter, Slack unfurling -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="/guides/rhinopython/primer-101/8-geometry/">
  <meta property="og:title" content="8 Geometry">
  <meta property="og:description" content="">
  <meta property="”og:site_name”" content="developer.rhino3d.com">
  <meta property="”og:image”" content="http://developer.rhino3d.com/images/rhinodev-logo-unfurl.png">

  <!-- twitter card tags additive with the og: tags -->
  <meta name="twitter:domain" value="developer.rhino3d.com">
  <meta name="twitter:title" value="8 Geometry">
  <meta name="twitter:description" value="">
  
    <meta name="twitter:image" content="http://developer.rhino3d.com/images/rhinodev-logo-unfurl.png">
  
  <meta name="twitter:url" value="http://developer.rhino3d.com">
  
  <meta name="twitter:label1" value="Platform(s)">
  <meta name="twitter:data1" value="Windows, Mac">
  
  
  <meta name="twitter:label2" value="Language(s)">
  <meta name="twitter:data2" value="Python">
  

  <link rel="stylesheet" href="./8 Geometry with Python_files/github.min.css">
  <script type="text/javascript" async="" src="./8 Geometry with Python_files/analytics.js"></script><script async="" src="./8 Geometry with Python_files/gtm.js"></script><script type="text/javascript" src="./8 Geometry with Python_files/highlight.min.js"></script>
  <script src="./8 Geometry with Python_files/vbnet.min.js"></script>
  <script src="./8 Geometry with Python_files/yaml.min.js"></script>
  <script src="./8 Geometry with Python_files/highlightjs-line-numbers.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>hljs.initLineNumbersOnLoad();</script>

  <!-- Overridden theme -->
  <link rel="stylesheet" href="./8 Geometry with Python_files/main.css">

  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="./8 Geometry with Python_files/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  <!-- Optional theme -->
  <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous"> -->
  <!-- Bootstrap override -->
  <link rel="stylesheet" href="./8 Geometry with Python_files/bootstrap-override.css">

  <link rel="canonical" href="http://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/">
  <link rel="alternate" type="application/rss+xml" title="Rhino Developer Docs" href="http://developer.rhino3d.com/feed.xml">

  <link rel="shortcut icon" href="https://developer.rhino3d.com/favicon.ico?v=2">
  <!-- Saving bookmarks to mobile devices -->
  <!-- For non-Retina (@1× display) iPhone, iPod Touch, and Android 2.1+ devices: -->
  <link rel="apple-touch-icon-precomposed" href="https://developer.rhino3d.com/images/apple-touch-icon-precomposed.png"><!-- 57×57px -->
  <!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≤ 6: -->
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://developer.rhino3d.com/images/apple-touch-icon-72x72-precomposed.png">
  <!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≥ 7: -->
  <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://developer.rhino3d.com/images/apple-touch-icon-76x76-precomposed.png">
  <!-- For iPhone with @2× display running iOS ≤ 6: -->
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://developer.rhino3d.com/images/apple-touch-icon-114x114-precomposed.png">
  <!-- For iPhone with @2× display running iOS ≥ 7: -->
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://developer.rhino3d.com/images/apple-touch-icon-120x120-precomposed.png">
  <!-- For iPad with @2× display running iOS ≤ 6: -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://developer.rhino3d.com/images/apple-touch-icon-144x144-precomposed.png">
  <!-- For iPad with @2× display running iOS ≥ 7: -->
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://developer.rhino3d.com/images/apple-touch-icon-152x152-precomposed.png">
  <!-- For iPhone 6 Plus with @3× display: -->
  <link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://developer.rhino3d.com/images/apple-touch-icon-180x180-precomposed.png">
  <!-- For Chrome for Android: -->
  <link rel="icon" sizes="192x192" href="https://developer.rhino3d.com/images/touch-icon-192x192.png">

  <!-- Diable crawling until this version is the stable version -->
  <!--<meta name="robots" content="noindex" />-->
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-bold; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Main-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Math-italic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Caligraphic; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.1') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.1') format('woff'), url('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.1') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>


  <body><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>

    <!-- Google Tag Manager **This belongs right after the <body> tag**-->
    <noscript>
        <iframe src="//www.googletagmanager.com/ns.html?id=GTM-MWMDKN"
        height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>
    <script>
        (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-MWMDKN');
    </script>
    <!-- End Google Tag Manager -->


    

<!-- The following are "casts" from the string to number using math filters... -->



<!-- ...but we need to check to see if the original branches were numbers or not... -->









  <div class="version-banner">

    
      
        
        
          <!-- <strong>NEW:</strong> Welcome to the <strong>Rhino 6</strong> version of this page! <a href="/5/guides/rhinopython/primer-101/8-geometry/">Looking for the older Rhino 5 version?</a> -->
          Welcome to the <strong>Rhino 6</strong> version of this page!
          <a href="https://developer.rhino3d.com/wip/guides/rhinopython/primer-101/8-geometry/">Looking for the newer Rhino 7 WIP version?</a>
        
        
      
    
</div>

<!-- Check the version banner for broken links and remove the link if found -->
<script src="./8 Geometry with Python_files/jquery.min.js"></script>
<!-- <script>
$(document).ready(function()
{
  var splitPath = window.location.pathname.split("/");
  var linkURL = "/5/" + splitPath.splice(1,splitPath.length-1).join("/");

  $.get(linkURL).fail(function ()
  {
    var $aTag = $("div.version-banner > a");
    $aTag.text("Looking for the older Rhino 5 site?");
    $aTag.attr("href", "/5/");
  });
});
</script> -->


    <div class="container">

      <header class="site-header">


    <a class="site-title" href="https://developer.rhino3d.com/"><img src="./8 Geometry with Python_files/rhinodevlogo148x128.png" alt="Rhino Developer Docs" height="48" width="56"></a><a class="site-title" href="https://developer.rhino3d.com/">Rhino Developer Docs</a>

    <nav class="site-nav">
      <img class="menu-icon" src="./8 Geometry with Python_files/gi.svg">
      
      <div class="trigger">
      	<!--<a class="page-link" href="/">Welcome</a>-->
        <!-- get current page title and "collection" to figure out which nav
             link should be "active" -->
        
        
        
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
            
              
                
              
            
          
        
          
        
          
            
              
            
          
        
          
            
              
                
                  
                    <a class="page-link active" href="https://developer.rhino3d.com/guides/">Guides</a>
                    
                  
              
            
          
        
          
            
              
                
                  
                    <a class="page-link" href="https://developer.rhino3d.com/api/">API</a>
                    
                  
              
            
          
        
          
            
              
                
                  
                    <a class="page-link" href="https://developer.rhino3d.com/samples/">Samples</a>
                    
                  
              
            
          
        
          
            
          
        
          
            
              
                
                  
                    <a class="page-link" href="https://developer.rhino3d.com/videos/">Videos</a>
                    
                  
              
            
          
        
        <a class="page-link" href="https://discourse.mcneel.com/c/rhino-developer">Forums</a>
        <!-- Google Search Engine -->
        <!-- TODO Move to this site back into the Mcneel search, or use a simple site only search for results -->
        <div id="sitesearch">
            <!-- CSE Search Box Begins  -->
            <form id="search-box" name="search-box" onsubmit="sitesearchFunction()" action="https://developer.rhino3d.com/search-results.html">
                <input id="searchtext" type="search" name="q" size="24" value="" placeholder="Search">
                <input class="searchBox" type="submit" size="2" value=" ">
            </form>
			<script type="text/javascript">
			function sitesearchFunction(){
				var form_id = document.getElementById("search-box");
				var form_action = form_id.action;
                var form_sb = document.getElementById("searchtext");
				var query_src = form_sb.value + " site:developer.rhino3d.com";
				form_sb.value = query_src.toString();
			}
			</script>
<!-- Google CSE Search Box Ends -->
        </div>
        <!--End of Google Search Engine -->
      </div>
    </nav>

</header>


      <div class="page-content">
        <!--div class="wrapper"-->
          <div class="container-fluid">

<div class="row-fluid">
    <!--Nav Bar -->
    <nav class="col-xs-0 col-md-3 bs-docs-sidebar">
    <ul id="sidebar" class="nav nav-stacked fixed">
        <!-- Find the h2 group and any h3 subgroups -->
        

        
          

          
            
            
            
            
            <li class="">
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#81-the-opennurbs-kernel">8.1 The openNURBS™ kernel</a>

              

            </li>
          

        
          

          
            
            
            
            
            <li class="">
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#82-objects-in-rhino">8.2 Objects in Rhino</a>

              

            </li>
          

        
          

          
            
            
            
            
            <li class="">
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#83-points-and-pointclouds">8.3 Points and Pointclouds</a>

              

            </li>
          

        
          

          
            
            
            
            
            <li class="">
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#84-lines-and-polylines">8.4 Lines and Polylines</a>

              

            </li>
          

        
          

          
            
            
            
            
            <li class="active">
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#85-planes">8.5 Planes</a>

              

            </li>
          

        
          

          
            
            
            
            
            <li class="">
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#86-circles-ellipses-and-arcs">8.6 Circles, Ellipses and...</a>

              
                <ul class="nav nav-stacked">
                  

                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#861-ellipses">8.6.1 Ellipses</a>
                    </li>
                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#862-arcs">8.6.2 Arcs</a>
                    </li>
                  

                </ul>
              

            </li>
          

        
          

          
            
            
            
            
            <li>
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#87-nurbs-curves">8.7 Nurbs-curves</a>

              
                <ul class="nav nav-stacked">
                  

                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#871-control-point-curves">8.7.1 Control-point curves</a>
                    </li>
                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#872-interpolated-curves">8.7.2 Interpolated curves</a>
                    </li>
                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#873-geometric-curve-properties">8.7.3 Geometric curve pro...</a>
                    </li>
                  

                </ul>
              

            </li>
          

        
          

          
            
            
            
            
            <li>
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#88-meshes">8.8 Meshes</a>

              
                <ul class="nav nav-stacked">
                  

                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#881-geometry-vs-topology">8.8.1 Geometry vs. Topology</a>
                    </li>
                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#882-shape-vs-image">8.8.2 Shape vs. Image</a>
                    </li>
                  

                </ul>
              

            </li>
          

        
          

          
            
            
            
            
            <li>
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#89-surfaces">8.9 Surfaces</a>

              
                <ul class="nav nav-stacked">
                  

                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#891-nurbs-surfaces">8.9.1 NURBS Surfaces</a>
                    </li>
                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#892-surface-curvature">8.9.2 Surface Curvature</a>
                    </li>
                  
                    
                    
                    
                    
                    
                    <li>
                        <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#893-vector-and-tensor-spaces">8.9.3 Vector and Tensor s...</a>
                    </li>
                  

                </ul>
              

            </li>
          

        
          

          
            
            
            
            
            <li>
              <a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/8-geometry/#next-steps">Next Steps</a>

              

            </li>
          

        
    </ul>
</nav>


    <!--Main Content -->
    <div class="col-xs-12 col-md-9">
      <!--<div class="post">-->

        <article class="post-content">

          <ol class="breadcrumb">
              
              
              
              <li><a href="https://developer.rhino3d.com/guides/rhinopython">RhinoPython</a></li>

              
                <li class="active"><a href="https://developer.rhino3d.com/guides/rhinopython/primer-101/">Rhino.Python 101</a></li>
              
          </ol>

          <h1>8 Geometry</h1>

          <p>
  <span class="guide_byline">
    
    
    by
      
        
        <a href="https://developer.rhino3d.com/authors/skylar_tibbits">Skylar Tibbits</a>
         and
      
        
        <a href="https://developer.rhino3d.com/authors/arthur_van_der_harten">Arthur van der Harten</a>
         and
      
        
        <a href="https://developer.rhino3d.com/authors/steve_baer">Steve Baer</a>
        
           (Last modified: <a href="https://github.com/mcneel/developer-rhino3d-com/commits/6/_guide_topics/rhinopython/primer-101/8-geometry.md" target="_blank">05 Dec 2018</a>)
    
  </span>

</p>

          <p></p>

          <h2 id="81-the-opennurbs-kernel">8.1 The openNURBS™ kernel</h2>

<p>Now that you are familiar with the basics of scripting, it is time to start with the actual geometry part of Rhino. To keep things interesting we’ve used plenty of Rhino methods in examples before now, but that was all peanuts. Now you will embark upon that great journey which, if you survive, will turn you into a real 3D geek.</p>

<p>As already mentioned in Chapter 3, Rhinoceros is built upon the openNURBS™ kernel which supplies the bulk of the geometry and file I/O functions. All plugins that deal with geometry tap into this rich resource and the RhinoScriptSytnax plugin is no exception. Although Rhino is marketed as a “NURBS modeler”, it does have a basic understanding of other types of geometry as well. Some of these are available to the general Rhino user, others are only available to programmers. When writting in Python you will not be dealing directly with any
openNURBS™ code since RhinoScriptSyntax wraps it all up into an easy-to-swallow package. However, programmers need to have a much higher level of comprehension than users which is why we’ll dig fairly deep.</p>

<h2 id="82-objects-in-rhino">8.2 Objects in Rhino</h2>

<p>All objects in Rhino are composed of a geometry part and an attribute part. There are quite a few different geometry types but the attributes always follow the same format. The attributes store information such as object name, color, layer, isocurve density, linetype and so on. Not all attributes make sense for all geometry types, points for example do not use linetypes or materials but they are capable of storing this information nevertheless. Most attributes and properties are fairly straightforward and can be read and assigned to objects at will.</p>

<p><img src="./8 Geometry with Python_files/primer-rhinoobjects.svg" class="img-center" width="90%"></p>

<p>This table lists most of the attributes and properties which are available to plugin developers. Most of these have been wrapped in the RhinoScriptSyntax module, others are missing at this point in time and the custom user data element is special. We’ll get to user data after we’re done with the basic geometry chapters.</p>

<p>The following procedure displays some attributes of a single object in a dialog box. There is nothing exciting going on here so I’ll refrain from providing a step-by-step explanation.</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</code><code class="language-python hljs"><span class="hljs-keyword">import</span> rhinoscriptsyntax <span class="hljs-keyword">as</span> rs

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">displayobjectattributes</span><span class="hljs-params">(object_id)</span>:</span>
    source = <span class="hljs-string">"By Layer"</span>, <span class="hljs-string">"By Object"</span>, <span class="hljs-string">"By Parent"</span>
    data = []
    data.append( <span class="hljs-string">"Object attributes for :"</span>+str(object_id) )
    data.append( <span class="hljs-string">"Description: "</span> + rs.ObjectDescription(object_id))
    data.append( <span class="hljs-string">"Layer: "</span> + rs.ObjectLayer(object_id))
    <span class="hljs-comment">#data.append( "LineType: " + rs.ObjectLineType(object_id))</span>
    <span class="hljs-comment">#data.append( "LineTypeSource: " + rs.ObjectLineTypeSource(object_id))</span>
    data.append( <span class="hljs-string">"MaterialSource: "</span> + str(rs.ObjectMaterialSource(object_id)))

    name = rs.ObjectName(object_id)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name: data.append(<span class="hljs-string">"&lt;Unnamed object&gt;"</span>)
    <span class="hljs-keyword">else</span>: data.append(<span class="hljs-string">"Name: "</span> + name)

    groups = rs.ObjectGroups(object_id)
    <span class="hljs-keyword">if</span> groups:
        <span class="hljs-keyword">for</span> i,group <span class="hljs-keyword">in</span> enumerate(groups):
            data.append( <span class="hljs-string">"Group(%d): %s"</span> % i+<span class="hljs-number">1</span>, group )
    <span class="hljs-keyword">else</span>:
        data.append(<span class="hljs-string">"&lt;Ungrouped object&gt;"</span>)

    s = <span class="hljs-string">""</span>
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data: s += line + <span class="hljs-string">"\n"</span>
    rs.EditBox(s, <span class="hljs-string">"Object attributes"</span>, <span class="hljs-string">"RhinoPython"</span>)


<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">"__main__"</span>:
    id = rs.GetObject()
    displayobjectattributes(id)
</code></pre>

<p><img src="./8 Geometry with Python_files/primer-objectattributedialog.png" class="img-center" width="45%"></p>

<h2 id="83-points-and-pointclouds">8.3 Points and Pointclouds</h2>

<p>Everything begins with points. A point is nothing more than a list of values called a coordinate. The number of values in the list corresponds with the number of dimensions of the space it resides in. Space is usually denoted with an R and a superscript value indicating the number of dimensions. (The ‘R’ stems from the world ‘real’ which means the space is continuous. We should keep in mind that a digital representation always has gaps, even though we are rarely confronted with them.)</p>

<p>Points in 3D space, or R3 thus have three coordinates, usually referred to as [x,y,z]. Points in R2 have only two coordinates which are either called [x,y] or [u,v] depending on what kind of two dimensional space we’re talking about. Points in R1 are denoted with a single value. Although we tend not to think of one-dimensional points as ‘points’, there is no mathematical difference; the same rules apply. One-dimensional points are often referred to as ‘parameters’ and we denote them with [t] or [p].</p>

<p><img src="./8 Geometry with Python_files/primer-rhinospaces.svg" class="img-center" width="90%"></p>

<p>The image on the left shows the R3 world space, it is continuous and infinite. The x-coordinate of a point in this space is the projection (the red dotted line) of that point onto the x-axis (the red solid line). Points are always specified in world coordinates in Rhino.</p>

<p>R2 world space (not drawn) is the same as R3 world space, except that it lacks a z-component. It is still continuous
and infinite. R2 parameter space however is bound to a finite surface as shown in the center image. It is still continuous, I.e. hypothetically there is an infinite amount of points on the surface, but the maximum distance between any of these points is very much limited. R2 parameter coordinates are only valid if they do not exceed a certain range. In the example drawing the range has been set between 0.0 and 1.0 for both [u] and [v]directions, but it could be any finite domain. A point with coordinates [1.5, 0.6] would be somewhere outside the surface and thus invalid.</p>

<p>Since the surface which defines this particular parameter space resides in regular R3 world space, we can always translate a parametric coordinate into a 3d world coordinate. The point [0.2, 0.4] on the surface for example is the same as point [1.8, 2.0, 4.1] in world coordinates. Once we transform or deform the surface, the R3 coordinates which correspond with [0.2, 0.4] will change. Note that the opposite is not true, we can translate any R2 parameter coordinate into a 3D world coordinate, but there are many 3D world coordinates that are not on the surface and which can therefore not be written as an R2 parameter coordinate. However, we can always project a 3D world coordinate onto the surface using the closest-point relationship. We’ll discuss this in more detail later on.</p>

<p>If the above is a hard concept to swallow, it might help you to think of yourself and your position in space. We usually tend to use local coordinate systems to describe our whereabouts; “I’m sitting in the third seat on the seventh row in the movie theatre”, “I live in apartment 24 on the fifth floor”, “I’m in the back seat”. Some of these are variations to the global coordinate system (latitude, longitude, elevation), while others use a different anchor point. If the car you’re in is on the road, your position in global coordinates is changing all the time, even though you remain in the same back seat ‘coordinate’.</p>

<p>Let’s start with conversion from R1 to R3 space. The following script will add 500 colored points to the
document, all of which are sampled at regular intervals across the R1 parameter space of a curve object:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</code><code class="language-python hljs"><span class="hljs-keyword">import</span> rhinoscriptsyntax <span class="hljs-keyword">as</span> rs

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    curve_id = rs.GetObject(<span class="hljs-string">"Select a curve to sample"</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> curve_id: <span class="hljs-keyword">return</span>

    rs.EnableRedraw(<span class="hljs-keyword">False</span>)
    t = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> t&lt;=<span class="hljs-number">1.0</span>:
        addpointat_r1_parameter(curve_id,t)
        t+=<span class="hljs-number">0.002</span>
    rs.EnableRedraw(<span class="hljs-keyword">True</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addpointat_r1_parameter</span><span class="hljs-params">(curve_id, parameter)</span>:</span>
    domain = rs.CurveDomain(curve_id)


    r1_param = domain[<span class="hljs-number">0</span>] + parameter*(domain[<span class="hljs-number">1</span>]-domain[<span class="hljs-number">0</span>])
    r3point = rs.EvaluateCurve(curve_id, r1_param)
    <span class="hljs-keyword">if</span> r3point:
        point_id = rs.AddPoint(r3point)
        rs.ObjectColor(point_id, parametercolor(parameter))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parametercolor</span><span class="hljs-params">(parameter)</span>:</span>
    red = <span class="hljs-number">255</span> * parameter
    <span class="hljs-keyword">if</span> red&lt;<span class="hljs-number">0</span>: red=<span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> red&gt;<span class="hljs-number">255</span>: red=<span class="hljs-number">255</span>
    <span class="hljs-keyword">return</span> (red,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>-red)

<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">"__main__"</span>:
    main()
</code></pre>

<p><img src="./8 Geometry with Python_files/primer-curveparameterspace.svg" class="img-center" width="45%"></p>

<p>For no good reason whatsoever, we’ll start with the bottom most function:</p>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>24</td>
<td>Standard out-of-the-box function declaration which takes a single double value. This function is
supposed to return a colour which changes gradually from blue to red as parameter changes from zero to one. Values outside of the range {0.0~1.0} will be clipped.</td>
</tr>
<tr>
<td>25</td>
<td>The red component of the colour we're going to return is declared here and assigned the naive value of 255 times the parameter. Colour components must have a value between and including 0 and 255. If we attempt to construct a colour with lower or higher values a run-time error will spoil the party.</td>
</tr>
<tr>
<td>26...27</td>
<td>Here's where we make sure the party can continue unimpeded.</td>
</tr>
<tr>
<td>28</td>
<td>Compute the colour gradient value. If parameter equals zero we want blue (0,0,255) and if it equals one we want red (255,0,0). So the green component is always zero while blue and red see-saw between 0 and 255.</td>
</tr>
</tbody></table>

<p>Now, on to function <em>AddPointAtR1Parameter()</em>. As the name implies, this function will add a single point in 3D world space based on the parameter coordinate of a curve object. In order to work correctly this function must know what curve we’re talking about and what parameter we want to sample. Instead of passing the actual parameter which is bound to the curve domain (and could be anything) we’re passing a unitized one.
I.e. we pretend the curve domain is between zero and one. This function will have to wrap the required math for translating unitized parameters into actual parameters.</p>

<p>Since we’re calling this function a lot (once for every point we want to add), it is actually a bit odd to put all the heavy-duty stuff inside it. We only really need to perform the overhead costs of ‘unitized parameter + actual parameter’ calculation once, so it makes more sense to put it in a higher level function. Still, it will be very quick so there’s no need to optimize it yet.</p>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>14</td>
<td>Function declaration.</td>
</tr>
<tr>
<td>15...16</td>
<td>Get the curve domain and check for <i>Null</i>. It will be <i>Null</i> if the ID does not represent a proper curve object. The <i>Rhino.CurveDomain()</i> method will return an array of two doubles which indicate the minimum and maximum t-parameters which lie on the curve.</td>
</tr>
<tr>
<td>18</td>
<td>Translate the unitized R1 coordinate into actual domain coordinates.</td>
</tr>
<tr>
<td>19</td>
<td>Evaluate the curve at the specified parameter. Rhino.EvaluateCurve() takes an R1 coordinate and returns an R3 coordinate.</td>
</tr>
<tr>
<td>21</td>
<td>Add the point, it will have default attributes.</td>
</tr>
<tr>
<td>22</td>
<td>Set the custom colour. This will automatically change the color-source attribute to By Object.</td>
</tr>
</tbody></table>

<p>The distribution of R1 points on a spiral is not very enticing since it approximates a division by equal length segments in R3 space. When we run the same script on less regular curves it becomes easier to grasp what parameter space is all about:</p>

<p><img src="./8 Geometry with Python_files/primer-curvestructure.svg" class="img-center" width="100%"></p>

<p>Let’s take a look at an example which uses all parameter spaces we’ve discussed so far:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</code><code class="language-python hljs"><span class="hljs-keyword">import</span> rhinoscriptsyntax <span class="hljs-keyword">as</span> rs

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    surface_id = rs.GetObject(<span class="hljs-string">"Select a surface to sample"</span>, <span class="hljs-number">8</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> surface_id: <span class="hljs-keyword">return</span>

    curve_id = rs.GetObject(<span class="hljs-string">"Select a curve to measure"</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> curve_id: <span class="hljs-keyword">return</span>

    points = rs.DivideCurve(curve_id, <span class="hljs-number">500</span>)
    rs.EnableRedraw(<span class="hljs-keyword">False</span>)
    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points: evaluatedeviation(surface_id, <span class="hljs-number">1.0</span>, point)
    rs.EnableRedraw(<span class="hljs-keyword">True</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluatedeviation</span><span class="hljs-params">( surface_id, threshold, sample )</span>:</span>
    r2point = rs.SurfaceClosestPoint(surface_id, sample)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> r2point: <span class="hljs-keyword">return</span>

    r3point = rs.EvaluateSurface(surface_id, r2point[<span class="hljs-number">0</span>], r2point[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> r3point: <span class="hljs-keyword">return</span>

    deviation = rs.Distance(r3point, sample)
    <span class="hljs-keyword">if</span> deviation&lt;=threshold: <span class="hljs-keyword">return</span>

    rs.AddPoint(sample)
    rs.AddLine(sample, r3point)

<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">"__main__"</span>:
    main()
</code></pre>

<p><img src="./8 Geometry with Python_files/primer-surfaceparameterspace.svg" alt="/images/primer-surfaceparameterspace.svg" class="float-img-right" width="325"></p>

<p>This script will compare a bunch of points on a curve to their projection on a surface. If the distance exceeds one unit, a line and a point will be added.</p>

<p>First, the R1 points are translated into R3 coordinates so we can
project them onto the surface, getting the R2 coordinate [u,v] in return. This R2 point has to be translated into R3 space as well, since we need to know the distance between the R1 point on the curve and the R2 point on the surface. Distances can only be measured if both points reside in the same number of dimensions, so we need to translate them into R3 as well.</p>

<p>Told you it was a piece of cake…</p>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>10</td>
<td>We're using the <i>Rhino.DivideCurve()</i> method to get all the R3 coordinates on the curve in one go. This saves us a lot of looping and evaluating.</td>
</tr>
<tr>
<td>24</td>
<td><i>Rhino.SurfaceClosestPoint()</i> returns an array of two doubles representing the R2 point on the surface (in {u,v} coordinates) which is closest to the sample point.</td>
</tr>
<tr>
<td>27</td>
<td>Rhino.EvaluateSurface() in turn translates the R2 parameter coordinate into R3 world coordinates</td>
</tr>
<tr>
<td>30...38</td>
<td>Compute the distance between the two points and add geometry if necessary. This function returns True if the deviation is less than one unit, False if it is more than one unit and Null if something went wrong.</td>
</tr>
</tbody></table>

<p>One more time just for kicks. We project the R1 parameter coordinate on the curve into 3D space (Step A), then we project that R3 coordinate onto the surface getting the R2 coordinate of the closest point (Step B). We evaluate the surface at R2, getting the R3 coordinate in 3D world space (Step C), and we finally measure the distance between the two R3 points to determine the deviation:</p>

<p><img src="./8 Geometry with Python_files/primer-surfaceparameterspacediagram.svg" class="img-center" width="60%"></p>

<h2 id="84-lines-and-polylines">8.4 Lines and Polylines</h2>

<p>You’ll be glad to learn that (poly)lines are essentially the same as point-lists. The only difference is that we treat the points as a series rather than an anonymous collection, which enables us to draw lines between them. There is some nasty stuff going on which might cause problems down the road so perhaps it’s best to get it over with quick.</p>

<p>There are several ways in which polylines can be manifested in openNURBS™ and thus in Rhino. There is a special polyline class which is simply a list of ordered points. It has no overhead data so this is the simplest case. It’s also possible for regular nurbs curves to behave as polylines when they have their degree set to 1. In addition, a polyline could also be a polycurve made up of line segments, polyline segments, degree=1 nurbs curves or a combination of the above. If you create a polyline using the _Polyline command, you will get a proper polyline object as the Object Properties Details dialog on the left shows:</p>

<p><img src="./8 Geometry with Python_files/PolyLineToNurbsDragChange.png" class="img-center" width="90%"></p>

<p>The dialog claims an “Open polyline with 8 points”. However, when we drag a control-point Rhino will
automatically convert any curve to a Nurbs curve, as the image on the right shows. It is now an open nurbs curve of degree=1. From a geometric point of view, these two curves are identical. From a programmatic point of view, they are anything but. For the time being we will only deal with ‘proper’ polylines though; lists of sequential coordinates. For purposes of clarification I’ve added two example functions which perform basic operations on polyline point-lists.</p>

<p>Compute the length of a polyline point-array:</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PolylineLength</span><span class="hljs-params">(arrVertices)</span>:</span>
    PolylineLength = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(arrVertices)<span class="hljs-number">-1</span>):
        PolylineLength = PolylineLength + rs.Distance(arrVertices[i], arrVertices[i+<span class="hljs-number">1</span>])
</code></pre>

<p>Subdivide a polyline by adding extra vertices halfway between all existing vertices:</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SubDividePolyline</span><span class="hljs-params">(arrV)</span>
    <span class="hljs-title">arrSubD</span> = []

    <span class="hljs-title">for</span> <span class="hljs-title">i</span> <span class="hljs-title">in</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">0</span>, len<span class="hljs-params">(arrV)</span><span class="hljs-number">-1</span>)</span>:</span>
        <span class="hljs-string">'copy the original vertex location
        arrSubD.append(arrV[i])
        '</span>compute the average of the current vertex <span class="hljs-keyword">and</span> the next one
        arrSubD.append([arrV[i][<span class="hljs-number">0</span>] + arrV[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]] / <span class="hljs-number">2.0</span>, _
                                    [arrV(i][<span class="hljs-number">1</span>] + arrV[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]] / <span class="hljs-number">2.0</span>, _
                                    [arrV[i][<span class="hljs-number">2</span>] + arrV[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]] / <span class="hljs-number">2.0</span>])

    <span class="hljs-string">'copy the last vertex (this is skipped by the loop)
    arrSubD.append(arrV[len(arrV)])
    return arrSubD
</span></code></pre>

<p>No rocket science yet, but brace yourself for the next bit…</p>

<p><img src="./8 Geometry with Python_files/primer-r2shortpath.svg" alt="/images/primer-r2shortpath.svg" class="float-img-right" width="325"></p>

<p>As you know, the shortest path between two points is a straight line. This is true for all our space definitions, from R1 to RN. However, the shortest path in R2 space is not necessarily the same shortest path in R3 space. If we want to connect two points on a surface with a straight line in R2, all we need to do is plot a linear course through the surface [u,v] space. (Since we can only add curves to Rhino which use 3D world coordinates, we’ll need a fair amount of samples to give the impression of smoothness.) The thick red curve in the
adjacent illustration is the shortest path in R2 parameter
space connecting [A] and [B]. We can clearly see that this is definitely not the shortest path in R3 space.</p>

<p>We can clearly see this because we’re used to things happening in R3 space, which is why this whole R2/R3 thing is so thoroughly counter intuitive to begin with. The green, dotted curve is the actual shortest path in R3 space which still respects the limitation of the surface (I.e. it can be projected onto the surface without any loss of information). The following function was used to create the red curve; it creates a polyline which represents the shortest path from [A] to [B] in surface parameter space:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getr2pathonsurface</span><span class="hljs-params">(surface_id, segments, prompt1, prompt2)</span>:</span>
    start_point = rs.GetPointOnSurface(surface_id, prompt1)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> start_point: <span class="hljs-keyword">return</span>

    end_point = rs.GetPointOnSurface(surface_id, prompt2)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> end_point: <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">if</span> rs.Distance(start_point, end_point)==<span class="hljs-number">0.0</span>: <span class="hljs-keyword">return</span>

    uva = rs.SurfaceClosestPoint(surface_id, start_point)
    uvb = rs.SurfaceClosestPoint(surface_id, end_point)

    path = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(segments):
        t = i / segments
        u = uva[<span class="hljs-number">0</span>] + t*(uvb[<span class="hljs-number">0</span>] - uva[<span class="hljs-number">0</span>])
        v = uva[<span class="hljs-number">1</span>] + t*(uvb[<span class="hljs-number">1</span>] - uva[<span class="hljs-number">1</span>])
        pt = rs.EvaluateSurface(surface_id, u, v)
        path.append(pt)
    <span class="hljs-keyword">return</span> path
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>This function takes four arguments; the ID of the surface onto which to plot the shortest route, the number of segments for the path polyline and the prompts to use for picking the A and B point.</td>
</tr>
<tr>
<td>1...3</td>
<td>Prompt the user for the {A} point on the surface. Return if the user does not enter a point.</td>
</tr>
<tr>
<td>5...6</td>
<td>Prompt the user for the {B} point on the surface. Return if the user does not enter a point.</td>
</tr>
<tr>
<td>10...11</td>
<td>Project {A} and {B} onto the surface to get the respective R2 coordinates <i>uva</i> and <i>uvb</i>.</td>
</tr>
<tr>
<td>13</td>
<td>Declare the list which is going to store all the polyline vertices.</td>
</tr>
<tr>
<td>14</td>
<td>Since this algorithm is segment-based, we know in advance how many vertices the polyline will have and thus how often we will have to sample the surface.</td>
</tr>
<tr>
<td>15</td>
<td><i>t</i> is a value which ranges from 0.0 to 1.0 over the course of our loop</td>
</tr>
<tr>
<td>16...17</td>
<td>Use the current value of <i>t</i> to sample the surface somewhere in between <i>uvA</i> and <i>uvB</i>.</td>
</tr>
<tr>
<td>18</td>
<td><i>rs.EvaluateSurface()</i> takes a {u} and a {v} value and spits out a 3D-world coordinate. This is just a friendly way of saying that it converts from R2 to R3.</td>
</tr>
</tbody></table>

<p>We’re going to combine the previous examples in order to make a real geodesic path routine in Rhino. This is a fairly complex algorithm and I’ll do my best to explain to you how it works before we get into any actual code.</p>

<p>First we’ll create a polyline which describes the shortest path between [A] and [B] in R2 space. This is our base curve. It will be a very coarse approximation, only ten segments in total. We’ll create it using the function on page 54. Unfortunately that function does not take closed surfaces into account. In the paragraph on nurbs surfaces we’ll elaborate on this.</p>

<p>Once we’ve got our base shape we’ll enter the iterative part. The iteration consists of two nested loops, which we will put in two different functions in order to avoid too much nesting and indenting. We’re going to write four functions in addition to the ones already discussed in this paragraph:</p>

<ul>
  <li>The main geodesic routine</li>
  <li>ProjectPolyline()</li>
  <li>SmoothPolyline()</li>
  <li>GeodesicFit()</li>
</ul>

<p>The purpose of the main routine is the same as always; to collect the initial data and make sure the script completes as successfully as possible. Since we’re going to calculate the geodesic curve between two points on a surface, the initial data consists only of a surface ID and two points in surface parameter space. The algorithm for finding the geodesic curve is a relatively slow one and it is not very good at making major changes to dense polylines. That is why we will be feeding it the problem in bite-size chunks. It is because of this reason that our initial base curve (the first bite) will only have ten segments. We’ll compute the geodesic path for these ten segments, then subdivide the curve into twenty segments and recompute the geodesic, then subdivide into 40 and so on and so forth until further subdivision no longer results in a shorter overall curve.</p>

<p>The <em>ProjectPolyline()</em> function will be responsible for making sure all the vertices of a polyline point-array are in fact coincident with a certain surface. In order to do this it must project the R3 coordinates of the polyline onto the surface, and then again evaluate that projection back into R3 space. This is called ‘pulling’.</p>

<p>The purpose of <em>SmoothPolyline()</em> will be to average all polyline vertices with their neighbours. This function will be very similar to our previous example, except it will be much simpler since we know for a fact we’re not dealing with nurbs curves here. We do not need to worry about knots, weights, degrees and domains.</p>

<p><em>GeodesicFit()</em> is the essential geodesic routine. We expect it to deform any given polyline into the best possible geodesic curve, no matter how coarse and wrong the input is. The algorithm in question is a very naive solution to the geodesic problem and it will run much slower than Rhinos native _ShortPath command. The upside is that our script, once finished, will be able to deal with self-intersecting surfaces.</p>

<p>The underlying theory of this algorithm is synonymous with the simulation of a contracting rubber band, with the one difference that our rubber band is not allowed to leave the surface. The process is iterative and though we expect every iteration to yield a certain improvement over the last one, the amount of improvement will diminish as we near the ideal solution. Once we feel the improvement has become negligible we’ll abort the function.</p>

<p>In order to simulate a rubber band we require two steps; smoothing and projecting. First we allow the rubber band to contract (it always wants to contract into a straight line between [A] and [B]). This contraction happens in R3 space which means the vertices of the polyline will probably end up away from the surface. We must then re-impose these surface constraints. These two operations have been hoisted into functions #2 and #3.</p>

<p><img src="./8 Geometry with Python_files/primer-geodesiccurvediagram.svg" class="img-center" width="65%"></p>

<p>The illustration depicts the two steps which compose a single iteration of the geodesic routine. The black polyline is projected onto the surface giving the red polyline. The red curve in turn is smoothed into the green  curve. Note that the actual algorithm performs these two steps in the reverse order; smoothing first, projection second.</p>

<p>We’ll start with the simplest function:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">projectpolyline</span><span class="hljs-params">(vertices, surface_id)</span>:</span>
    polyline = []
    <span class="hljs-keyword">for</span> vertex <span class="hljs-keyword">in</span> vertices:
        pt = rs.BrepClosestPoint(surface_id, vertex)
        <span class="hljs-keyword">if</span> pt: polyline.append(pt[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> polyline
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1...3</td>
<td>Since this is a specialized def which we will only be using inside this script, we can skip projecting the first and last point. We can safely assume the polyline is open and that both endpoints will already be on the curve.</td>
</tr>
<tr>
<td>4</td>
<td>We ask Rhino for the closest point on the surface object given our polyline vertex coordinate. The reason why we do not use <i>rs.SurfaceClosestPoint()</i> is because <i>BRepClosestPoint()</i> takes trims into account. This is a nice bonus we can get for free. The native <i>_ShortPath</i> command does not deal with trims at all. We are of course not interested in aping something which already exists, we want to make something better.</td>
</tr>
<tr>
<td>5</td>
<td>If <i>BRepClosestPoint()</i> returned Null something went wrong after all. We cannot project the vertex in this case so we'll simply ignore it. We could of course short-circuit the whole operation after a failure like this, but I prefer to press on and see what comes out the other end. </td>
</tr>
<tr>
<td>6</td>
<td>The <i>BRepClosestPoint()</i> method returns a lot of information, not just the R2 coordinate. In fact it returns a tuple of data, the first element of which is the R3 closest point. This means we do not have to translate the uv coordinate into xyz ourselves. Huzzah! Assign it to the vertex and move on.</td>
</tr>
</tbody></table>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothpolyline</span><span class="hljs-params">(vertices)</span>:</span>
    smooth = []
    smooth.append(vertices[<span class="hljs-number">0</span>])

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(vertices)<span class="hljs-number">-1</span>):
        prev = vertices[i<span class="hljs-number">-1</span>]
        this = vertices[i]
        next = vertices[i+<span class="hljs-number">1</span>]
        pt = (prev+this+next) / <span class="hljs-number">3.0</span>
        smooth.append(pt)
    smooth.append(vertices[len(vertices)<span class="hljs-number">-1</span>])
    <span class="hljs-keyword">return</span> smooth
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1...3 6...8</td>
<td>Since we need the original coordinates throughout the smoothing operation we cannot deform it
directly. That is why we need to make a copy of each vertex point before we start messing about with coordinates.</td>
</tr>
<tr>
<td>9</td>
<td>What we do here is average the x, y and z coordinates of the current vertex ('current' as defined by i) using both itself and its neighbours.
<br><br>
We iterate through all the internal vertices and add the Point3d objects together, rather than explicitly adding their x, y and z components together. Writing smaller functions will not make the code go faster, but it does mean we just get to write less junk. Also, it means adjustments are easier to make afterwards since less code-rewriting is required.</td>
</tr>
</tbody></table>

<p>Time for the bit that sounded so difficult on the previous page, the actual geodesic curve fitter routine:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">geodesicfit</span><span class="hljs-params">(vertices, surface_id, tolerance)</span>:</span>
    length = polylinelength(vertices)
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        vertices = smoothpolyline(vertices)
        vertices = projectpolyline(vertices, surface_id)
        newlength = polylinelength(vertices)
        <span class="hljs-keyword">if</span> abs(newlength-length)&lt;tolerance: <span class="hljs-keyword">return</span> vertices
        length = newlength
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>Hah... that doesn't look so bad after all, does it? You'll notice that it's often the stuff which is easy to explain that ends up taking a lot of lines of code. Rigid mathematical and logical structures can typically be coded very efficiently.</td>
</tr>
<tr>
<td>2</td>
<td>We'll be monitoring the progress of each iteration and once the curve no longer becomes noticeably shorter (where 'noticeable' is defined by the <i>tolerance</i> argument), we'll call the 'intermediate result' the 'final result' and return execution to the caller. In order to monitor this progress, we need to remember how long the curve was before we started; <i>length</i> is created for this purpose.</td>
</tr>
<tr>
<td>3</td>
<td>Whenever you see a while True: without any standard escape clause you should be on your toes. This is potentially an infinite loop. I have tested it rather thoroughly and have been unable to make it run more than 120 times. Experimental data is never watertight proof, the routine could theoretically fall into a stable state where it jumps between two solutions. If this happens, the loop will run forever.
<br><br>
You are of course welcome to add additional escape clauses if you deem that necessary.</td>
</tr>
<tr>
<td>4...5</td>
<td>Place the calls to the functions on page 56. These are the bones of the algorithm.</td>
</tr>
<tr>
<td>6</td>
<td>Compute the new length of the polyline.</td>
</tr>
<tr>
<td>7</td>
<td>Check to see whether or not it is worth carrying on.</td>
</tr>
<tr>
<td>8</td>
<td>Apparently it was, we need now to remember this new length as our frame of reference.</td>
</tr>
</tbody></table>

<p>The main subroutine takes some explaining. It performs a lot of different tasks which always makes a block of code harder to read. It would have been better to split it up into more discrete chunks, but we’re already using seven different functions for this script and I feel we are nearing the ceiling. Remember that splitting problems into smaller parts is a good way to organize your thoughts, but it doesn’t actually solve anything. You’ll need to find a good balance between splitting and lumping.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">geodesiccurve</span><span class="hljs-params">()</span>:</span>
    surface_id = rs.GetObject(<span class="hljs-string">"Select surface for geodesic curve solution"</span>, <span class="hljs-number">8</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> surface_id: <span class="hljs-keyword">return</span>

    vertices = getr2pathonsurface(surface_id, <span class="hljs-number">10</span>, <span class="hljs-string">"Start of geodes curve"</span>, <span class="hljs-string">"End of geodes curve"</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vertices: <span class="hljs-keyword">return</span>

    tolerance = rs.UnitAbsoluteTolerance() / <span class="hljs-number">10</span>
    length = <span class="hljs-number">1e300</span>
    newlength = <span class="hljs-number">0.0</span>

    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        print(<span class="hljs-string">"Solving geodesic fit for %d samples"</span> % len(vertices))
        vertices = geodesicfit(vertices, surface_id, tolerance)

        newlength = polylinelength(vertices)
        <span class="hljs-keyword">if</span> abs(newlength-length)&lt;tolerance: <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> len(vertices)&gt;<span class="hljs-number">1000</span>: <span class="hljs-keyword">break</span>
        vertices = subdividepolyline(vertices)
        length = newlength

    rs.AddPolyline(vertices)
    <span class="hljs-keyword">print</span> <span class="hljs-string">"Geodesic curve added with length: "</span>, newlength
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2...3</td>
<td>Get the surface to be used in the geodesic routine.</td>
</tr>
<tr>
<td>5...6</td>
<td>Declare a variable which will store the polyline vertices. Since the return value of <i>getr2pathonsurface()</i> is already a list, we do not need to declare it with empty brackets - '[ ]' - as we have done elsewhere.</td>
</tr>
<tr>
<td>8</td>
<td>The tolerance used in our script will be 10% of the absolute tolerance of the document.</td>
</tr>
<tr>
<td>9...12</td>
<td>This loop also uses a length comparison in order to determine whether or not to continue. But instead of evaluating the length of a polyline before and after a smooth/project iteration, it measures the difference before and after a subdivide/geodesicfit iteration. The goal of this evaluation is to decide whether or not further elaboration will pay off. The variables <i>length</i> and <i>newlength</i> are used in the same context as on the previous page.</td>
</tr>
<tr>
<td>13</td>
<td>Display a message in the command-line informing the user about the progress we're making. This script may run for quite some time so it's important not to let the user think the damn thing has crashed.</td>
</tr>
<tr>
<td>14</td>
<td>Place a call to the <i>GeodesicFit()</i> subroutine.</td>
</tr>
<tr>
<td>16...17</td>
<td>Compare the improvement in length, exit the loop when there's no progress of any value.</td>
</tr>
<tr>
<td>18</td>
<td>A safety-switch. We don't want our curve to become too dense.</td>
</tr>
<tr>
<td>19</td>
<td>A call to <i>subdividepolyline()</i> will double the amount of vertices in the polyline. The newly added vertices will not be on the surface, so we must make sure to call <i>geodesicfit()</i> at least once before we add this new polyline to the document.</td>
</tr>
<tr>
<td>22...23</td>
<td>Add the curve and print a message about the length.</td>
</tr>
</tbody></table>

<h2 id="85-planes">8.5 Planes</h2>

<p>Planes are not genuine objects in Rhino, they are used to define a coordinate system in 3D world space. In fact, it’s best to think of planes as vectors, they are merely mathematical constructs. Although planes are internally defined by a parametric equation, I find it easiest to think of them as a set of axes:</p>

<p><img src="./8 Geometry with Python_files/primer-planedefinition.svg" class="img-center" width="45%"></p>

<p>A plane definition is an array of one point and three vectors, the point marks the origin of the plane and the vectors represent the three axes. There are some rules to plane definitions, I.e. not every combination of points and vectors is a valid plane. If you create a plane using one of the RhinoScriptSyntax plane methods you don’t have to worry about this, since all the bookkeeping will be done for you. The rules are as follows:</p>

<ul>
  <li>The axis vectors must be unitized (have a length of 1.0).</li>
  <li>All axis vectors must be perpendicular to each other.</li>
  <li>The x and y axis are ordered anti-clockwise.</li>
</ul>

<p>The illustration shows how rules #2 and #3 work in practice.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
</code><code class="language-python hljs">ptOrigin = rs.GetPoint(<span class="hljs-string">"Plane origin"</span>)

ptX = rs.GetPoint(<span class="hljs-string">"Plane X-axis"</span>, ptOrigin)

ptY = rs.GetPoint(<span class="hljs-string">"Plane Y-axis"</span>, ptOrigin)

dX = rs.Distance(ptOrigin, ptX)
dY = rs.Distance(ptOrigin, ptY)
arrPlane = rs.PlaneFromPoints(ptOrigin, ptX, ptY)

rs.AddPlaneSurface(arrPlane, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)
rs.AddPlaneSurface(arrPlane, dX, dY)
</code></pre>

<p><img src="./8 Geometry with Python_files/primer-planecreation.svg" alt="/images/primer-planecreation.svg" class="float-img-right" width="325"></p>

<p>You will notice that all RhinoScriptSyntax methods that require plane definitions make sure these demands are met, no matter how poorly you defined the input.</p>

<p>The adjacent illustration shows how the rs.AddPlaneSurface() call on line 11 results in the red plane, while the rs.AddPlaneSurface() call on line 12 creates the yellow surface which has dimensions equal to the distance between the picked origin and axis points.</p>

<p>We’ll only pause briefly at plane definitions since planes, like vectors, are usually only constructive elements. In examples to come they will be used extensively so don’t worry about getting the hours in. A more interesting script which uses the <em>rs.AddPlaneSurface()</em> method is the one below which populates a surface with so-called surface frames:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</code><code class="language-python hljs">idSurface = rs.GetObject(<span class="hljs-string">"Surface to frame"</span>, <span class="hljs-number">8</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)

intCount = rs.GetInteger(<span class="hljs-string">"Number of iterations per direction"</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>)

uDomain = rs.SurfaceDomain(idSurface, <span class="hljs-number">0</span>)
vDomain = rs.SurfaceDomain(idSurface, <span class="hljs-number">1</span>)
uStep = (uDomain[<span class="hljs-number">1</span>] - uDomain[<span class="hljs-number">0</span>]) / intCount
vStep = (vDomain[<span class="hljs-number">1</span>] - vDomain[<span class="hljs-number">0</span>]) / intCount

rs.EnableRedraw(<span class="hljs-keyword">False</span>)
<span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> range(uDomain[<span class="hljs-number">0</span>],uDomain[<span class="hljs-number">1</span>], uStep):
    For v <span class="hljs-keyword">in</span> range(vdomain[<span class="hljs-number">0</span>],vDomain[<span class="hljs-number">1</span>],vStep):
        pt = rs.EvaluateSurface(idSurface, [u, v])
        <span class="hljs-keyword">if</span> rs.Distance(pt, rs.BrepClosestPoint(idSurface, pt)[<span class="hljs-number">0</span>]) &lt; <span class="hljs-number">0.1</span>:
            srfFrame = rs.SurfaceFrame(idSurface, [u, v])
            rs.AddPlaneSurface(srfFrame, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)

rs.EnableRedraw(<span class="hljs-keyword">True</span>)
</code></pre>

<p>Frames are planes which are used to indicate geometrical directions. Both curves, surfaces and textured meshes have frames which identify tangency and curvature in the case of curves and [u] and [v] directions in the case of surfaces and meshes. The script above simply iterates over the [u] and [v] directions of any given surface and adds surface frame objects at all uv coordinates it passes.</p>

<p><img src="./8 Geometry with Python_files/primersurfaceframes.svg" alt="/images/primersurfaceframes.svg" class="float-img-right" width="325"></p>

<p>On lines 5 and 6 we determine the domain of the surface in u and v directions and we derive the required stepsize from those limits.</p>

<p>Line 11 and 12 form the main structure of the two-dimensional iteration. You can read such nested For loops as “Iterate through all columns and inside every column iterate through all rows”.</p>

<p>Line 14 does something interesting which is not apparent in the adjacent illustration. When we are dealing with trimmed surfaces, those two lines prevent the script from adding planes in cut-away areas. By comparing the point on the (untrimmed) surface to it’s projection onto the trimmed surface, we know whether or not the [uv] coordinate in question represents an actual point on the trimmed surface.</p>

<p>The <em>rs.SurfaceFrame()</em> method returns a unitized frame whose axes point in the [u] and [v] directions of the surface. Note that the [u] and [v] directions are not necessarily perpendicular to each other, but we only add valid planes whose x and y axis are always at 90º, thus we ignore the direction of the v-component.</p>

<h2 id="86-circles-ellipses-and-arcs">8.6 Circles, Ellipses and Arcs</h2>

<p>Although the user is never confronted with parametric objects in Rhino, the openNURBS™ kernel has a certain set of mathematical primitives which are stored parametrically. Examples of these are cylinders, spheres, circles, revolutions and sum-surfaces. To highlight the difference between explicit (parametric) and implicit circles:</p>

<p><img src="./8 Geometry with Python_files/primer-circleschart.svg" class="img-center" width="100%"></p>

<p>When adding circles to Rhino through scripting, we can either use the Plane+Radius approach or we can use a 3-Point approach (which is internally translated into Plane+Radius). You may remember that circles are tightly linked with sines and cosines; those lovable, undulating waves. We’re going to create a script which packs circles with a predefined radius onto a sphere with another predefined radius. Now, before we start and I give away the answer, I’d like you to take a minute and think about this problem.</p>

<p>The most obvious solution is to start stacking circles in horizontal bands and simply to ignore any vertical nesting which might take place. If you reached a similar solution and you want to keep feeling good about yourself I recommend you skip the following two sentences. This very solution has been found over and over again but for some reason Dave Rusin is usually given as the inventor. Even though Rusin’s algorithm isn’t exactly rocket science, it is worth discussing the mathematics in advance to prevent -or at least reduce- any confusion when I finally confront you with the code.</p>

<p>Rusin’s algorithm works as follows:</p>

<ul>
  <li>Solve how many circles you can evenly stack from north pole to south pole on the sphere.</li>
  <li>For each of those bands, solve how many circles you can stack evenly around the sphere.</li>
  <li>Do it.</li>
</ul>

<p>No wait, back up. The first thing to realize is how a sphere actually works. Only once we master spheres can we start packing them with circles. In Rhino, a sphere is a surface of revolution, which has two singularities and a single seam:</p>

<p><img src="./8 Geometry with Python_files/primer-uv-map.svg" class="img-center" width="80%"></p>

<p>The north pole (the black dot in the left most image) and the south pole (the white dot in the same image) are both on the main axis of the sphere and the seam (the thick edge) connects the two. In essence, a sphere is a rectangular plane bent in two directions, where the left and right side meet up to form the seam and the top and bottom edge are compressed into a single point each (a singularity). This coordinate system should be familiar since we use the same one for our own planet. However, our planet is divided into latitude and longitude degrees, whereas spheres are defined by latitude and longitude radians. The numeric domain of the latitude of the sphere starts in the south pole with -½π, reaches 0.0 at the equator and finally terminates with ½π at the north pole. The longitudinal domain starts and stops at the seam and travels around the sphere from 0.0 to 2π. Now you also know why it is called a ‘seam’ in the first place; it’s where the domain suddenly jumps from one value to another, distant one.</p>

<p><img src="./8 Geometry with Python_files/primer-sphereuv.svg" alt="/images/primer-sphereuv.svg" class="float-img-left" width="275"></p>

<p>We cannot pack circles in the same way as we pack squares in the image above since that would deform them heavily near the poles, as indeed the squares are deformed. We want our circles to remain perfectly circular which means we have to fight the converging nature of the sphere</p>

<p>Assuming the radius of the circles we are about to stack is sufficiently smaller than the radius of the sphere, we can at least place two circles without thinking; one on the north- and one on the south pole. The additional benefit is that these two circles now handsomely cover up the singularities so we are only left with the annoying seam. The next order of business then, is to determine how many circles we need in order to cover up the seam in a straightforward fashion. The length of the seam is half of the circumference of the sphere (see yellow arrow in adjacent illustration).</p>

<p>Home stretch time, we’ve collected all the information we need in order to populate this sphere. The last step of the algorithm is to stack circles around the sphere, starting at every seam-circle. We need to calculate the circumference of the sphere at that particular latitude, divide that number by the diameter of the circles and once again find the largest integer value which is smaller than or equal to that result. The equivalent mathematical notation for this is:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;msub&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;&amp;#x22C5;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;&amp;#x22C5;&lt;/mo&gt;&lt;mi&gt;cos&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;&amp;#x03D5;&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;&amp;#x22C5;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 14.91em; display: inline-block;"><span style="display: inline-block; position: relative; width: 12.195em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.847em, 1011.94em, 4.562em, -999.997em); top: -3.43em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="msubsup" id="MathJax-Span-3"><span style="display: inline-block; position: relative; width: 2.615em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math-italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.822em;"><span class="texatom" id="MathJax-Span-5"><span class="mrow" id="MathJax-Span-6"><span class="mi" id="MathJax-Span-7" style="font-size: 70.7%; font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-8" style="font-size: 70.7%; font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-9" style="font-size: 70.7%; font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-10" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-11" style="font-size: 70.7%; font-family: MathJax_Math-italic;">t</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mrow" id="MathJax-Span-13" style="padding-left: 0.259em;"><span class="mo" id="MathJax-Span-14" style="vertical-align: 0em;"><span style="font-family: MathJax_Size3;">[</span></span><span class="mfrac" id="MathJax-Span-15"><span style="display: inline-block; position: relative; width: 7.021em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.128em, 1006.87em, 4.46em, -999.997em); top: -4.762em; left: 50%; margin-left: -3.43em;"><span class="mrow" id="MathJax-Span-16"><span class="mn" id="MathJax-Span-17" style="font-family: MathJax_Main;">2</span><span class="mo" id="MathJax-Span-18" style="font-family: MathJax_Main; padding-left: 0.207em;">⋅</span><span class="msubsup" id="MathJax-Span-19" style="padding-left: 0.207em;"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.77em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-20" style="font-family: MathJax_Math-italic;">R</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.771em;"><span class="texatom" id="MathJax-Span-21"><span class="mrow" id="MathJax-Span-22"><span class="mi" id="MathJax-Span-23" style="font-size: 70.7%; font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-24" style="font-size: 70.7%; font-family: MathJax_Math-italic;">p</span><span class="mi" id="MathJax-Span-25" style="font-size: 70.7%; font-family: MathJax_Math-italic;">h</span><span class="mi" id="MathJax-Span-26" style="font-size: 70.7%; font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-27" style="font-size: 70.7%; font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-28" style="font-size: 70.7%; font-family: MathJax_Math-italic;">e</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-29" style="font-family: MathJax_Main; padding-left: 0.207em;">⋅</span><span class="mi" id="MathJax-Span-30" style="font-family: MathJax_Main; padding-left: 0.207em;">cos</span><span class="mo" id="MathJax-Span-31"></span><span class="texatom" id="MathJax-Span-32" style="padding-left: 0.156em;"><span class="mrow" id="MathJax-Span-33"><span class="mi" id="MathJax-Span-34" style="font-family: MathJax_Math-italic;">ϕ</span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.179em, 1003.74em, 4.306em, -999.997em); top: -3.327em; left: 50%; margin-left: -1.893em;"><span class="mrow" id="MathJax-Span-35"><span class="mn" id="MathJax-Span-36" style="font-family: MathJax_Main;">2</span><span class="mo" id="MathJax-Span-37" style="font-family: MathJax_Main; padding-left: 0.207em;">⋅</span><span class="msubsup" id="MathJax-Span-38" style="padding-left: 0.207em;"><span style="display: inline-block; position: relative; width: 2.564em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.77em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">R</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.771em;"><span class="texatom" id="MathJax-Span-40"><span class="mrow" id="MathJax-Span-41"><span class="mi" id="MathJax-Span-42" style="font-size: 70.7%; font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-43" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-44" style="font-size: 70.7%; font-family: MathJax_Math-italic;">r</span><span class="mi" id="MathJax-Span-45" style="font-size: 70.7%; font-family: MathJax_Math-italic;">c</span><span class="mi" id="MathJax-Span-46" style="font-size: 70.7%; font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-47" style="font-size: 70.7%; font-family: MathJax_Math-italic;">e</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1007.02em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 7.021em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span><span class="mo" id="MathJax-Span-48" style="vertical-align: 0em;"><span style="font-family: MathJax_Size3;">]</span></span></span></span><span style="display: inline-block; width: 0px; height: 3.435em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -1.247em; border-left: 0px solid; width: 0px; height: 3.066em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo>[</mo><mfrac><mrow><mn>2</mn><mo>⋅</mo><msub><mi>R</mi><mrow class="MJX-TeXAtom-ORD"><mi>s</mi><mi>p</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi></mrow></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mrow class="MJX-TeXAtom-ORD"><mi>ϕ</mi></mrow></mrow><mrow><mn>2</mn><mo>⋅</mo><msub><mi>R</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>i</mi><mi>r</mi><mi>c</mi><mi>l</mi><mi>e</mi></mrow></msub></mrow></mfrac><mo>]</mo></mrow></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-1">N_{count} = \left[\frac{2 \cdot R_{sphere} \cdot \cos{\phi}}{2 \cdot R_{circle}} \right]</script>

<p>in case you need to impress anyone…</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DistributeCirclesOnSphere</span><span class="hljs-params">()</span>:</span>
    sphere_radius = rs.GetReal(<span class="hljs-string">"Radius of sphere"</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">0.01</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sphere_radius: <span class="hljs-keyword">return</span>

    circle_radius = rs.GetReal(<span class="hljs-string">"Radius of circles"</span>, <span class="hljs-number">0.05</span>*sphere_radius, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.5</span>*sphere_radius)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> circle_radius: <span class="hljs-keyword">return</span>

    vertical_count = int( (math.pi*sphere_radius)/(<span class="hljs-number">2</span>*circle_radius) )

    rs.EnableRedraw(<span class="hljs-keyword">False</span>)
    phi = <span class="hljs-number">-0.5</span>*math.pi
    phi_step = math.pi/vertical_count
    <span class="hljs-keyword">while</span> phi&lt;<span class="hljs-number">0.5</span>*math.pi:
        horizontal_count = int( (<span class="hljs-number">2</span>*math.pi*math.cos(phi)*sphere_radius)/(<span class="hljs-number">2</span>*circle_radius) )
        <span class="hljs-keyword">if</span> horizontal_count==<span class="hljs-number">0</span>: horizontal_count=<span class="hljs-number">1</span>
        theta = <span class="hljs-number">0</span>
        theta_step = <span class="hljs-number">2</span>*math.pi/horizontal_count
        <span class="hljs-keyword">while</span> theta&lt;<span class="hljs-number">2</span>*math.pi<span class="hljs-number">-1e-8</span>:
            circle_center = (sphere_radius*math.cos(theta)*math.cos(phi),
                sphere_radius*math.sin(theta)*math.cos(phi), sphere_radius*math.sin(phi))
            circle_normal = rs.PointSubtract(circle_center, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
            circle_plane = rs.PlaneFromNormal(circle_center, circle_normal)
            rs.AddCircle(circle_plane, circle_radius)
            theta += theta_step
        phi += phi_step
    rs.EnableRedraw(<span class="hljs-keyword">True</span>)
</code></pre>

<p><img src="./8 Geometry with Python_files/primer-spherepack.svg" class="img-center" width="45%"></p>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1...6</td>
<td>Collect all custom variables and make sure they make sense. We don't want spheres smaller than 0.01 units and we don't want circle radii larger than half the sphere radius.</td>
</tr>
<tr>
<td>8</td>
<td>Compute the number of circles from pole to pole. The <i>int()</i> function in VBScript takes a double and returns only the integer part of that number. Hence it always rounds downwards.</td>
</tr>
<tr>
<td>11...12<br>16...17</td>
<td>phi and theta (Φ and Θ) are typically used to denote angles in spherical space and it's not hard to see why. I could have called them latitude and longitude respectively as well.</td>
</tr>
<tr>
<td>13</td>
<td>The phi loop runs from -½π to ½π and we need to run it <i>VerticalCount</i> times.</td>
</tr>
<tr>
<td>14</td>
<td>This is where we calculate how many circles we can fit around the sphere on the current latitude. The math is the same as before, except we also need to calculate the length of the path around the sphere: 2π·R·Cos(Φ)</td>
</tr>
<tr>
<td>15</td>
<td>If it turns out that we can fit no circles at all at a certain latitude, we're going to get into trouble since we use the HorizontalCount variable as a denominator in the stepsize calculation on line 24. And even my mother knows you cannot divide by zero. However, we know we can always fit at least one circle.</td>
</tr>
<tr>
<td>18</td>
<td>This loop is essentially the same as the one on line 20, except it uses a different stepsize and a different numeric range ({0.0 &lt;= theta &lt; 2π} instead of {-½π &lt;= phi &lt;= +½π}). The more observant among you will have noticed that the domain of theta reaches from nought up to but not including two pi. If <i>theta</i> would go all the way up to 2π then there would be a duplicate circle on the seam. The best way of preventing a loop to reach a certain value is to subtract a fraction of the stepsize from that value, in this case I have simply subtracted a ludicrously small number (1e-8 = 0.00000001).</td>
</tr>
<tr>
<td>19...21</td>
<td><i>circle_center</i> will be used to store the center point of the circles we're going to add.  
<i>circle_normal</i> will be used to store the normal of the plane in which these circles reside.  
<i>circle_plane</i> will be used to store the resulting plane definition.</td>
</tr>
<tr>
<td>19</td>
<td>This is mathematically the most demanding line, and I'm not going to provide a full proof of why and how it works. This is the standard way of translating the spherical coordinates Φ and Θ into Cartesian coordinates x, y and z.
<br><br>
Further information can be found on [MathWorld.com](http://mathworld.wolfram.com/)</td>
</tr>
<tr>
<td>20</td>
<td>Once we found the point on the sphere which corresponds to the current values of phi and theta, it's a piece of proverbial cake to find the normal of the sphere at that location. The normal of a sphere at any point on its surface is the inverted vector from that point to the center of the sphere. And that's what we do on line 29, we subtract the sphere origin (always (0,0,0) in this script) from the newly found {x,y,z} coordinate.</td>
</tr>
<tr>
<td>21...22</td>
<td>We can construct a plane definition from a single point on that plane and a normal vector and we can construct a circle from a plane definition and a radius value. Voila.</td>
</tr>
</tbody></table>

<h3 id="861-ellipses">8.6.1 Ellipses</h3>

<p>Ellipses essentially work the same as circles, with the difference that you have to supply two radii instead of just one. Because ellipses only have two mirror symmetry planes and circles possess rotational symmetry (I.e. an infinite number of mirror symmetry planes), it actually does matter a great deal how the base-plane is oriented in the case of ellipses. A plane specified merely by origin and normal vector is free to rotate around that vector without breaking any of the initial constraints.</p>

<p>The following example script demonstrates very clearly how the orientation of the base plane and the ellipse correspond. Consider the standard curvature analysis graph as shown on the left:</p>

<p><img src="./8 Geometry with Python_files/primer-curvaturespline.svg" class="img-center" width="80%"></p>

<p>It gives a clear impression of the range of different curvatures in the spline, but it doesn’t communicate the helical twisting of the curvature very well. Parts of the spline that are near-linear tend to have a garbled curvature since they are the transition from one well defined bend to another. The arrows in the left image indicate these areas of twisting but it is hard to deduce this from the curvature graph alone. The upcoming script will use the curvature information to loft a surface through a set of ellipses which have been oriented into the curvature plane of the local spline geometry. The ellipses have a small radius in the bending plane of the curve and a large one perpendicular to the bending plane. Since we will not be using the strength of the curvature but only its orientation, small details will become very apparent.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FlatWorm</span><span class="hljs-params">()</span>:</span>
    curve_object = rs.GetObject(<span class="hljs-string">"Pick a backbone curve"</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">False</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> curve_object: <span class="hljs-keyword">return</span>

    samples = rs.GetInteger(<span class="hljs-string">"Number of cross sections"</span>, <span class="hljs-number">100</span>, <span class="hljs-number">5</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> samples: <span class="hljs-keyword">return</span>

    bend_radius = rs.GetReal(<span class="hljs-string">"Bend plane radius"</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.001</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> bend_radius: <span class="hljs-keyword">return</span>

    perp_radius = rs.GetReal(<span class="hljs-string">"Ribbon plane radius"</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.001</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> perp_radius: <span class="hljs-keyword">return</span>

    crvdomain = rs.CurveDomain(curve_object)

    crosssections = []
    t_step = (crvdomain[<span class="hljs-number">1</span>]-crvdomain[<span class="hljs-number">0</span>])/samples
    t = crvdomain[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> rs.frange(crvdomain[<span class="hljs-number">0</span>], crvdomain[<span class="hljs-number">1</span>], t_step):
        crvcurvature = rs.CurveCurvature(curve_object, t)
        crosssectionplane = <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> crvcurvature:
            crvPoint = rs.EvaluateCurve(curve_object, t)
            crvTangent = rs.CurveTangent(curve_object, t)
            crvPerp = (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
            crvNormal = rs.VectorCrossProduct(crvTangent, crvPerp)
            crosssectionplane = rs.PlaneFromFrame(crvPoint, crvPerp, crvNormal)
        <span class="hljs-keyword">else</span>:
            crvPoint = crvcurvature[<span class="hljs-number">0</span>]
            crvTangent = crvcurvature[<span class="hljs-number">1</span>]
            crvPerp = rs.VectorUnitize(crvcurvature[<span class="hljs-number">4</span>])
            crvNormal = rs.VectorCrossProduct(crvTangent, crvPerp)
            crosssectionplane = rs.PlaneFromFrame(crvPoint, crvPerp, crvNormal)

        <span class="hljs-keyword">if</span> crosssectionplane:
            csec = rs.AddEllipse(crosssectionplane, bend_radius, perp_radius)
            crosssections.append(csec)
        t += t_step

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> crosssections: <span class="hljs-keyword">return</span>
    rs.AddLoftSrf(crosssections)
    rs.DeleteObjects(crosssections)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>16</td>
<td><i>crosssections</i> is a list where we will store all our ellipse IDs. We need to remember all the ellipses we add since they have to be fed to the <i>rs.AddLoftSrf()</i> method. <i>crosssectionplane</i> will contain the base plane data for every individual ellipse, we do not need to remember these planes so we can afford to overwrite the old value with any new one.
You'll notice I'm violating a lot of naming conventions from paragraph [2.3.5 Using Variables]. If you want to make something of it we can take it outside. </td>
</tr>
<tr>
<td>19</td>
<td>We'll be walking along the curve with equal parameter steps. This is arguably not the best way, since we might be dealing with a polycurve which has wildly different parameterizations among its subcurves. This is only an example script though so I wanted to keep the code to a minimum. We're using the same trick as before in the header of the loop to ensure that the final value in the domain is included in the calculation. By extending the range of the loop by one billionth of a parameter we circumvent the 'double noise problem' which might result from multiple additions of doubles.</td>
</tr>
<tr>
<td>20</td>
<td>The <i>rs.CurveCurvature()</i> method returns a whole set of data to do with curvature analysis. However, it will fail on any linear segment (the radius of curvature is infinite on linear segments).</td>
</tr>
<tr>
<td>22...27</td>
<td>Hence, if it fails we have to collect the standard information in the old fashioned way. We also have to pick a <i>crvPerp</i> vector since none is available. We could perhaps use the last known one, or look at the local plane of the curve beyond the current -unsolvable- segment, but I've chosen to simply use a z-axis vector by default.</td>
</tr>
<tr>
<td>28...32</td>
<td>If the curve does have curvature at t, then we extract the required information directly from the curvature data.</td>
</tr>
<tr>
<td>33</td>
<td>Construct the plane for the ellipse.</td>
</tr>
<tr>
<td>35...37</td>
<td>Add the ellipse to the file and append the new ellipse curve ID csec to the list <i>crosssections</i>.</td>
</tr>
<tr>
<td>40...42</td>
<td>Create a lofted surface through all ellipses and delete the curves afterwards.</td>
</tr>
</tbody></table>

<h3 id="862-arcs">8.6.2 Arcs</h3>

<p>Since the topic of Arcs isn’t much different from the topic of Circles, I thought it would be a nice idea to drag in something extra. This something extra is what we programmers call “recursion” and it is without doubt the most exciting thing in our lives (we don’t get out much). Recursion is the process of self-repetition. Like loops which are iterative and execute the same code over and over again, recursive functions call themselves and thus also execute the same code over and over again, but this process is hierarchical. It actually sounds harder than it is. One of the success stories of recursive functions is their implementation in binary trees which are the foundation for many search and classification algorithms in the world today. I’ll allow myself a small detour on the subject of recursion because I would very much like you to appreciate the power that flows from the simplicity of the technique. Recursion is unfortunately one of those things which only become horribly obvious once you understand how it works.</p>

<p>Imagine a box in 3D space which contains a number of points within its volume. This box exhibits a single behavioral pattern which is recursive. The recursive function evaluates a single conditional statement: {when the number of contained points exceeds a certain threshold value then subdivide into 8 smaller boxes, otherwise add yourself to the document}. It would be hard to come up with an easier If…Else statement. Yet, because this behavior is also exhibited by all newly created boxes, it bursts into a chain of recursion, resulting in the voxel spaces in the images below:</p>

<p><img src="./8 Geometry with Python_files/primer-threshold.svg" class="img-center" width="80%"></p>

<p>The input in these cases was a large pointcloud shaped like the upper half of a sphere. There was also a dense spot with a higher than average concentration of points. Because of the approximating pattern of the subdivision, the recursive cascade results in these beautiful stacks. Trying to achieve this result without the use of recursion would entail a humongous amount of bookkeeping and many, many lines of code.
Before we can get to the cool bit we have to write some of the supporting functions, which -I hate to say it- once again involve goniometry (the mathematics of angles).</p>

<p>The problem: adding an arc using the start point, end point and start direction. As you will be aware there is a way to do this directly in Rhino using the mouse. In fact a brief inspection yields 14 different ways in which arcs can be drawn in Rhino manually and yet there are only two ways to add arcs through scripting:</p>

<ul>
  <li>rs.AddArc(Plane, Radius, Angle)</li>
  <li>rs.AddArc3Pt(Point, Point, Point)</li>
</ul>

<p>The first way is very similar to adding circles using plane and radius values, with the added argument for sweep angle. The second way is also similar to adding circles using a 3-point system, with the difference that the arc terminates at the first and second point. There is no direct way to add arcs from point A to point B while constrained to a start tangent vector. We’re going to have to write a function which translates the desired Start-End-Direction approach into a 3-Point approach. Before we tackle the math, let’s review how it works:</p>

<p><img src="./8 Geometry with Python_files/primer-arcs.svg" alt="/images/primer-arcs.svg" class="float-img-left" width="275"></p>

<p>We start with two points {A} &amp; {B} and a vector definition {D}. The arc we’re after is the red curve, but at this point we don’t know how to get there yet. Note that this problem might not have a solution if {D} is parallel or anti-parallel to the line from {A} to {B}. If you try to draw an arc like that in Rhino it will not work. Thus, we need to add some code to our function that aborts when we’re confronted with unsolvable input.</p>

<p>We’re going to find the coordinates of the point in the middle of the desired arc {M}, so we can use the 3Point approach with {A}, {B} and {M}. As the illustration on the left indicates, the point in the middle of the arc is also on the line perpendicular from the middle {C} of the baseline.</p>

<p>The halfway point on the arc also happens to lie on the bisector between {D} and the baseline vector. We can easily construct the bisector of two vectors in 3D space by process of unitizing and adding both vectors. In the illustration on the left the bisector is already pointing in the right direction, but it still hasn’t got the correct length.</p>

<p>We can compute the correct length using the standard “Sin-Cos-Tan right triangle rules”:</p>

<p>The triangle we have to solve has a 90º angle in the lower right corner, a is the angle between the baseline and the bisector, the length of the bottom edge of the triangle is half the distance between {A} and {B} and we need to compute the length of the slant edge (between {A} and {M}).</p>

<p>The relationship between a and the lengths of the sides of the triangle is:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;cos&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;&amp;#x03B1;&lt;/mi&gt;&lt;/mrow&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;/mfrac&gt;&lt;mo&gt;&amp;#x226B;&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;cos&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;&amp;#x03B1;&lt;/mi&gt;&lt;/mrow&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mrow&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;&amp;#x226B;&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;cos&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;&amp;#x03B1;&lt;/mi&gt;&lt;/mrow&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-49" style="width: 25.207em; display: inline-block;"><span style="display: inline-block; position: relative; width: 20.648em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(0.669em, 1020.6em, 3.332em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-50"><span class="mi" id="MathJax-Span-51" style="font-family: MathJax_Main;">cos</span><span class="mo" id="MathJax-Span-52"></span><span class="mo" id="MathJax-Span-53" style="font-family: MathJax_Main;">(</span><span class="texatom" id="MathJax-Span-54"><span class="mrow" id="MathJax-Span-55"><span class="mi" id="MathJax-Span-56" style="font-family: MathJax_Math-italic;">α</span></span></span><span class="mo" id="MathJax-Span-57" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-58" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mfrac" id="MathJax-Span-59" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 2.205em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.179em, 1002.1em, 4.152em, -999.997em); top: -4.659em; left: 50%; margin-left: -1.073em;"><span class="mrow" id="MathJax-Span-60"><span class="mn" id="MathJax-Span-61" style="font-family: MathJax_Main;">0.5</span><span class="mi" id="MathJax-Span-62" style="font-family: MathJax_Math-italic;">D</span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.128em, 1000.41em, 4.152em, -999.997em); top: -3.327em; left: 50%; margin-left: -0.254em;"><span class="mo" id="MathJax-Span-63" style="font-family: MathJax_Main;">?</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1002.21em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 2.205em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span><span class="mo" id="MathJax-Span-64" style="font-family: MathJax_Main; padding-left: 0.259em;">≫</span><span class="mfrac" id="MathJax-Span-65" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 2.871em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.179em, 1000.41em, 4.152em, -999.997em); top: -4.659em; left: 50%; margin-left: -0.254em;"><span class="mn" id="MathJax-Span-66" style="font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.076em, 1002.67em, 4.408em, -999.997em); top: -3.276em; left: 50%; margin-left: -1.381em;"><span class="mrow" id="MathJax-Span-67"><span class="mi" id="MathJax-Span-68" style="font-family: MathJax_Main;">cos</span><span class="mo" id="MathJax-Span-69"></span><span class="mo" id="MathJax-Span-70" style="font-family: MathJax_Main;">(</span><span class="texatom" id="MathJax-Span-71"><span class="mrow" id="MathJax-Span-72"><span class="mi" id="MathJax-Span-73" style="font-family: MathJax_Math-italic;">α</span></span></span><span class="mo" id="MathJax-Span-74" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1002.87em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 2.871em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span><span class="mo" id="MathJax-Span-75" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mfrac" id="MathJax-Span-76"><span style="display: inline-block; position: relative; width: 2.205em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.128em, 1000.41em, 4.152em, -999.997em); top: -4.659em; left: 50%; margin-left: -0.254em;"><span class="mo" id="MathJax-Span-77" style="font-family: MathJax_Main;">?</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.179em, 1002.1em, 4.152em, -999.997em); top: -3.327em; left: 50%; margin-left: -1.073em;"><span class="mrow" id="MathJax-Span-78"><span class="mn" id="MathJax-Span-79" style="font-family: MathJax_Main;">0.5</span><span class="mi" id="MathJax-Span-80" style="font-family: MathJax_Math-italic;">D</span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1002.21em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 2.205em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span><span class="mo" id="MathJax-Span-81" style="font-family: MathJax_Main; padding-left: 0.259em;">≫</span><span class="mfrac" id="MathJax-Span-82" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 2.871em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.179em, 1002.1em, 4.152em, -999.997em); top: -4.659em; left: 50%; margin-left: -1.073em;"><span class="mrow" id="MathJax-Span-83"><span class="mn" id="MathJax-Span-84" style="font-family: MathJax_Main;">0.5</span><span class="mi" id="MathJax-Span-85" style="font-family: MathJax_Math-italic;">D</span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.076em, 1002.67em, 4.408em, -999.997em); top: -3.276em; left: 50%; margin-left: -1.381em;"><span class="mrow" id="MathJax-Span-86"><span class="mi" id="MathJax-Span-87" style="font-family: MathJax_Main;">cos</span><span class="mo" id="MathJax-Span-88"></span><span class="mo" id="MathJax-Span-89" style="font-family: MathJax_Main;">(</span><span class="texatom" id="MathJax-Span-90"><span class="mrow" id="MathJax-Span-91"><span class="mi" id="MathJax-Span-92" style="font-family: MathJax_Math-italic;">α</span></span></span><span class="mo" id="MathJax-Span-93" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1002.87em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 2.871em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span><span class="mo" id="MathJax-Span-94" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mo" id="MathJax-Span-95" style="font-family: MathJax_Main;">?</span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -1.247em; border-left: 0px solid; width: 0px; height: 3.003em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi>α</mi></mrow><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>0.5</mn><mi>D</mi></mrow><mo>?</mo></mfrac><mo>≫</mo><mfrac><mn>1</mn><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi>α</mi></mrow><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mo>?</mo><mrow><mn>0.5</mn><mi>D</mi></mrow></mfrac><mo>≫</mo><mfrac><mrow><mn>0.5</mn><mi>D</mi></mrow><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi>α</mi></mrow><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mo>?</mo></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-2">\cos({\alpha})=\frac{0.5D}{?} \gg \frac{1}{\cos({\alpha})}=\frac{?}{0.5D} \gg \frac{0.5D}{\cos({\alpha})} = ?</script>

<p>We now have the equation we need in order to solve the length of the slant edge. The only remaining problem is cos(a). In the paragraph on vector mathematics (6.2 Points and Vectors) the vector dotproduct is briefly introduced as a way to compute the angle between two vectors. When we use unitized vectors, the arccosine of the dotproduct gives us the angle between them. This means the dotproduct returns the cosine of the angle between these vectors. This is a very fortunate turn of events since the cosine of the angle is exactly the thing we’re looking for. In other words, the dotproduct saves us from having to use the cosine and arccosine functions altogether. Thus, the distance between {A} and {M} is the result of:</p>

<pre><code class="language-python hljs">(<span class="hljs-number">0.5</span> * rs.Distance(A, B)) / rs.VectorDotProduct(D, Bisector)
</code></pre>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AddArcDir</span><span class="hljs-params">(ptStart, ptEnd, vecDir)</span>:</span>
    vecBase = rs.PointSubtract(ptEnd, ptStart)
    <span class="hljs-keyword">if</span> rs.VectorLength(vecBase)==<span class="hljs-number">0.0</span>: <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">if</span> rs.IsVectorParallelTo(vecBase, vecDir): <span class="hljs-keyword">return</span>

    vecBase = rs.VectorUnitize(vecBase)
    vecDir = rs.VectorUnitize(vecDir)

    vecBisector = rs.VectorAdd(vecDir, vecBase)
    vecBisector = rs.VectorUnitize(vecBisector)

    dotProd = rs.VectorDotProduct(vecBisector, vecDir)
    midLength = (<span class="hljs-number">0.5</span>*rs.Distance(ptStart, ptEnd))/dotProd

    vecBisector = rs.VectorScale(vecBisector, midLength)
    <span class="hljs-keyword">return</span> rs.AddArc3Pt(ptStart, rs.PointAdd(ptStart, vecBisector), ptEnd)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>The <i>ptStart</i> argument indicates the start of the arc, <i>ptEnd</i> the end and <i>vecDir</i> the direction at <i>ptStart</i>. This function will behave just like the <i>rs.AddArc3Pt()</i> method. It takes a set of arguments and returns the identifier of the created curve object if successful. If no curve was added the function does not return anything - that is, the resulting assignment will be <i>None</i>.</td>
</tr>
<tr>
<td>2</td>
<td>Create the baseline vector (from {A} to {B}), by subtracting {A} from {B}.</td>
</tr>
<tr>
<td>3</td>
<td>If {A} and {B} are coincident, then the subtraction from line 2 will result in a vector with a length of 0 and no solution is possible. Actually, there is an infinite number of solutions so we wouldn't know which one to pick.</td>
</tr>
<tr>
<td>5</td>
<td>If vecDir is parallel (or anti-parallel) to the baseline vector, then no solution is possible at all.</td>
</tr>
<tr>
<td>7...8</td>
<td>Make sure all vector definitions so far are unitized - that is, they all have a vector length value of one</td>
</tr>
<tr>
<td>10...11</td>
<td>Create the bisector vector and unitize it.</td>
</tr>
<tr>
<td>13</td>
<td>Compute the dotproduct between the bisector and the direction vector. Since the bisector is exactly halfway between the direction vector and baseline vector (indeed, that is the point to its existence), we could just as well have calculated the dotproduct between it and the baseline vector.</td>
</tr>
<tr>
<td>14</td>
<td>Compute the distance between ptStart and the center point of the desired arc.</td>
</tr>
<tr>
<td>16</td>
<td>Resize the (unitized) bisector vector to match this length.</td>
</tr>
<tr>
<td>17</td>
<td>Create an arc using the start, end and midpoint arguments, return the ID.</td>
</tr>
</tbody></table>

<p><img src="./8 Geometry with Python_files/primer-arctree.svg" alt="/images/primer-arctree.svg" class="float-img-right" width="375"></p>

<p>We need this function in order to build a recursive tree-generator which outputs trees made of arcs. Our trees will be governed by a set of five variables but -due to the
flexible nature of the recursive paradigm- it will be very easy to add more behavioral patterns. The growing algorithm as implemented in this example is very simple and doesn’t allow a great deal of variation.</p>

<p>The five base parameters are:</p>

<ol>
  <li>Propagation factor</li>
  <li>Twig length</li>
  <li>Twig length mutation</li>
  <li>Twig angle</li>
  <li>Twig angle mutation</li>
</ol>

<p>The propagation-factor is a numeric range which indicates the minimum and maximum number of twigs that grow at the end of every branch. This is a totally random affair, which is why it is called a “factor” rather than a “number”. More on random numbers in a minute. The twig-length and twig-length-mutation variables control the -as you probably guessed- length of the twigs and how the length changes with every twig generation. The twig-angle and twig-angle-mutation work in a similar fashion.</p>

<p>The actual recursive bit of this algorithm will not concern itself with the addition and shape of the twig-arcs. This is done by a supporting function which we have to write before we can start growing trees. The problem we have when adding new twigs, is that we want them to connect smoothly to their parent branch. We’ve already got the plumbing in place to make tangency continuous arcs, but we have no mechanism yet for picking the end-point. In our current plant-scheme, twig growth is controlled by two factors; length and angle. However, since more than one twig might be growing at the end of a branch there needs to be a certain amount of random variation to keep all the twigs from looking the same.</p>

<p><img src="./8 Geometry with Python_files/primer-branchpropagation2.svg" alt="/images/primer-branchpropagation2.svg" class="float-img-right" width="325"></p>

<p>The adjacent illustration shows the algorithm we’ll be using for twig propagation. The red curve is the branch-arc and we need to populate the end with any number of twig-arcs. Point {A} and Vector {D} are dictated by the shape of the branch but we are free to pick point {B} at random provided we remain within the limits set by the length and angle constraints. The complete set of possible end-points is drawn as the yellow cone. We’re going to use a sequence of Vector methods to get a random point {B} in this shape:</p>

<ol>
  <li>Create a new vector {T} parallel to {D}</li>
  <li>Resize {T} to have a length between {Lmin} and {Lmax}</li>
  <li>Mutate {T} to deviate a bit from {D}</li>
  <li>Rotate {T} around {D} to randomize the orientation</li>
</ol>

<p>&nbsp;</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">RandomPointInCone</span><span class="hljs-params">( origin, direction, minDistance, maxDistance, maxAngle)</span>:</span>
    vecTwig = rs.VectorUnitize(direction)
    vecTwig = rs.VectorScale(vecTwig, minDistance + random.random()*(maxDistance-minDistance))
    MutationPlane = rs.PlaneFromNormal((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), vecTwig)
    vecTwig = rs.VectorRotate(vecTwig, random.random()*maxAngle, MutationPlane[<span class="hljs-number">1</span>])
    vecTwig = rs.VectorRotate(vecTwig, random.random()*<span class="hljs-number">360</span>, direction)
    <span class="hljs-keyword">return</span> rs.PointAdd(origin, vecTwig)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td><i>origin</i> is synonymous with point {A}.
<i>direction</i> is synonymous with vector {D}.
<i>minDistance</i> and MaxDistance indicate the length-wise domain of the cone.
<i>maxAngle</i> is a value which specifies the angle of the cone (in degrees, not radians).</td>
</tr>
<tr>
<td>2...3</td>
<td>Create a new vector parallel to <i>Direction</i> and resize it to be somewhere between <i>MinDistance</i> and <i>MaxDistance</i>. I'm using the <i>random()</i> function here which is a Python pseudo-random-number frontend. It always returns a random value between zero and one.</td>
</tr>
<tr>
<td>4</td>
<td>In order to mutate <i>vecTwig</i>, we need to find a parallel vector. since we only have one vector here we cannot directly use the <i>Rhino.VectorCrossProduct()</i> method, so we'll construct a plane and use its x-axis. This vector could be pointing anywhere, but always perpendicular to <i>vecTwig</i>.</td>
</tr>
<tr>
<td>5</td>
<td>Mutate <i>vecTwig</i> by rotating a random amount of degrees around the plane x-axis.</td>
</tr>
<tr>
<td>6</td>
<td>Mutate <i>vecTwig</i> again by rotating it around the <i>Direction</i> vector. This time the random angle is between 0 and 360 degrees.</td>
</tr>
<tr>
<td>7</td>
<td>Create the new point as inferred by <i>Origin</i> and <i>vecTwig</i>.</td>
</tr>
</tbody></table>

<p>One of the definitions Wikipedia has to offer on the subject of recursion is: “In order to understand recursion, one must first understand recursion.” Although this is obviously just meant to be funny, there is an unmistakable truth as well. The upcoming script is recursive in every definition of the word, it is also quite short, it produces visually interesting effects and it is quite clearly a very poor realistic plant generator. The perfect characteristics for exploration by trial-and-error. Probably more than any other example script in this primer this one is a lot of fun to play around with. Modify, alter, change, mangle and bend it as you see fit.</p>

<p>There is a set of rules to which any working recursive function must adhere. It must place at least one call to itself somewhere before the end and must have a way of exiting without placing any calls to itself. If the first condition is not met the function cannot be called recursive and if the second condition is not met it will call itself until time stops (or rather until the call-stack memory in your computer runs dry).</p>

<p>Lo and behold!
A mere 21 lines of code to describe the growth of an entire tree.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">RecursiveGrowth</span><span class="hljs-params">( ptStart, vecDir, props, generation)</span>:</span>
    minTwigCount, maxTwigCount, maxGenerations, maxTwigLength, lengthMutation, maxTwigAngle,...      
        angleMutation = props
    <span class="hljs-keyword">if</span> generation&gt;maxGenerations: <span class="hljs-keyword">return</span>

    <span class="hljs-comment">#Copy and mutate the growth-properties</span>
    newProps = props
    maxTwigLength *= lengthMutation
    maxTwigAngle *= angleMutation
    <span class="hljs-keyword">if</span> maxTwigAngle&gt;<span class="hljs-number">90</span>: maxTwigAngle=<span class="hljs-number">90</span>

    <span class="hljs-comment">#Determine the number of twigs (could be less than zero)</span>
    newprops = minTwigCount, maxTwigCount, maxGenerations, maxTwigLength, lengthMutation,...
        maxTwigAngle, angleMutation
    maxN = int( minTwigCount+random.random()*(maxTwigCount-minTwigCount) )
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,maxN):
        ptGrow = RandomPointInCone(ptStart, vecDir, <span class="hljs-number">0.25</span>*maxTwigLength, maxTwigLength,...
            maxTwigAngle)
        newTwig = AddArcDir(ptStart, ptGrow, vecDir)
        <span class="hljs-keyword">if</span> newTwig:
            vecGrow = rs.CurveTangent(newTwig, rs.CurveDomain(newTwig)[<span class="hljs-number">1</span>])
            RecursiveGrowth(ptGrow, vecGrow, newProps, generation+<span class="hljs-number">1</span>)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>A word on the function signature. Apart from the obvious arguments <i>ptStart</i> and <i>vecDir</i>, this function takes an tuple and a generation counter. The tuple contains all our growth variables. Since there are seven of them in total I didn't want to add them all as individual arguments. Also, this way it is easier to add parameters without changing function calls. The generation argument is an integer telling the function which twig generation it is in. Normally a recursive function does not need to know its depth in the grand scheme of things, but in our case we're making an exception since the number of generations is an exit threshold.</td>
</tr>
<tr>
<td>2</td>
<td>For readability, we will break our tuple into individual variables. On the assignment side, the variables are listed in the order that they appear in the tuple. The properties tuple consists of the following items:

<img src="./8 Geometry with Python_files/primer-data-table.svg" width="100%" float="right">
</td>
</tr>
<tr>
<td>3</td>
<td>If the current generation exceeds the generation limit (which is stored at the third element in the properties tuple, and broken out to the variable maxGenerations) this function will abort without calling itself. Hence, it will take a step back on the recursive hierarchy.</td>
</tr>
<tr>
<td>6</td>
<td>This is where we make a copy of the properties. You see, when we are going to grow new twigs, those twigs will be called with mutated properties, however we require the unmutated properties inside this function instance.</td>
</tr>
<tr>
<td>7...9</td>
<td>Mutate the copied properties. I.e. multiply the maximum-twig-length by the twig-length-mutation factor and do the same for the angle. We must take additional steps to ensure the angle doesn't go berserk so we're limiting the mutation to within the 90 degree realm.</td>
</tr>
<tr>
<td>13</td>
<td><i>maxN</i> is an integer which indicated the number of twigs we are about to grow. <i>maxN</i> is randomly picked between the two allowed extremes (<i>Props(0)</i> and <i>Props(1)</i>). The <i>random()</i> function generates a number between zero and one which means that maxN can become any value between and including the limits.</td>
</tr>
<tr>
<td>15</td>
<td>This is where we pick a point at random using the unmutated properties. The length constraints we're using is hard coded to be between the maximum allowed length and a quarter of the maximum allowed length. There is nothing in the universe which suggests a factor of 0.25, it is purely arbitrary. It does however have a strong effect on the shape of the trees we're growing. It means it is impossible to accurately specify a twig length. There is a lot of room for experimentation and change here.</td>
</tr>
<tr>
<td>16</td>
<td>We create the arc that belongs to this twig.</td>
</tr>
<tr>
<td>17</td>
<td>If the distance between <i>ptStart</i> and <i>ptGrow</i> was 0.0 or if <i>vecDir</i> was parallel to <i>ptStart</i> » <i>ptGrow</i> then the arc could not be added. We need to catch this problem in time.</td>
</tr>
<tr>
<td>18</td>
<td>We need to know the tangent at the end of the newly created arc curve.  The domain of a curve consists of two values (a lower and an upper bound). <i>Rhino.CurveDomain(newTwig)(1)</i> will return the upper bound of the domain. This is the same as calling:

<code lang="python">
crvDomain = rs.CurveDomain(newTwig)
vecGrow = rs.CurveTangent(newTwig, crvDomain[1])
</code>

</td>
</tr>
<tr>
<td>19</td>
<td>Awooga! Awooga! A function calling itself! This is it! We made it!
The thing to realize is that the call is now different. We're putting in different arguments which means this new function instance behaves differently than the current function instance.</td>
</tr>
</tbody></table>

<p>It would have been possible to code this tree-generator in an iterative (For loops) fashion. The tree would look the same even though the code would be very different (probably a lot more lines). The order in which the branches are added would very probably also have differed. The trees below are archetypal, digital trees, the one on the left generated using iteration, the one on the right generated using recursion. Note the difference in branch order. If you look carefully at the recursive function on the previous page you’ll probably be able to work out where this difference comes from…</p>

<p><img src="./8 Geometry with Python_files/primer_iterativetree_vs_recursivetree.svg" class="img-center" width="80%"></p>

<p>A small comparison table for different setting combinations. Please note that the trees have a very high random component.</p>

<p><img src="./8 Geometry with Python_files/primer-treechart.svg" class="img-center" width="100%"></p>

<h2 id="87-nurbs-curves">8.7 Nurbs-curves</h2>

<p>Circles and arcs are all fine and dandy, but they cannot be used to draw freeform shapes. For that you need splines. The worlds most famous spline is probably the Bézier curve, which was developed in 1962 by the French engineer <em>Pierre Bézier</em> while he was working for Renault. Most splines used in computer graphics these days are variations on the Bézier spline, and they are thus a surprisingly recent arrival on the mathematical scene. Other ground-breaking work on splines was done by <em>Paul de Casteljau</em> at Citroën and <em>Carl de Boor</em> at General Motors. The thing that jumps out here is the fact that all these people worked for car manufacturers. With the increase in engine power and road quality, the automobile industry started to face new problems halfway through the twentieth century, one of which was aerodynamics. New methods were needed to design mass-production cars that had smooth, fluent curves as opposed to the tangency and curvature fractured shapes of old. They needed mathematically accurate, freely adjustable geometry. Enter splines.</p>

<p>Before we start with NURBS curves (the mathematics of which are a bit too complex for a scripting primer) I’d like to give you a sense of how splines work in general and Béziers work in particular. I’ll explain the de Casteljau algorithm which is a very straightforward way of evaluating properties of simple splines. In practice, this algorithm will rarely be used since its performance is worse than alternate approaches, but due to its visual appeal it is easier to ‘get a feel’ for it.</p>

<p><img src="./8 Geometry with Python_files/primer-nurbsalgorithm.svg" class="img-center" width="100%"></p>

<p>Splines limited to four control points were not the end of the revolution of course. Soon, more advanced spline definitions were formulated one of which is the NURBS curve. (Just to set the record straight; NURBS stands for Non-Uniform Rational [Basic/Basis] Spline and not Bézier-Spline as some people think. In fact, the Rhino help file gets it right, but I doubt many of you have read the glossary section, I only found out just now.) Bézier splines are a subset of NURBS curves, meaning that every Bézier spline can be represented by a NURBS curve, but not the other way around. Other curve types still in use today (but not available in Rhino) are Hermite, Cardinal, Catmull-Rom, Beta and Akima splines, but this is not a complete list. Hermite curves for example are used by the Bongo animation plug-in to smoothly transform objects through a number of keyframes.</p>

<p>In addition to control point locations, NURBS curves have additional properties such as the degree, knot-vectors and weights. I’m going to assume that you already know how weight factors work (if you don’t, it’s in the Rhino help file under [NURBS About]) so I won’t discuss them here. Instead, we’ll continue with the correlation between degrees and knot-vectors.</p>

<p>Every NURBS curve has a number associated with it which represents the degree. The degree of a curve is always a positive integer between and including 1 and 11. The degree of a curve is written as DN. Thus D1 is a degree one curve and D3 is a degree three curve. The table on the next page shows a number of curves with the exact same control-polygon but with different degrees. In short, the degree of a curve determines the range of influence of control points. The higher the degree, the larger the range.</p>

<p>As you will recall from the beginning of this section, a quadratic Bézier curve is defined by four control points. A quadratic NURBS curve however can be defined by any number of control points (any number larger than three that is), which in turn means that the entire curve consists of a number of connected pieces. The illustration below shows a D3 curve with 10 control points. All the individual pieces have been given a different color. As you can see each piece has a rather simple shape; a shape you could approximate with a traditional, four-point Bézier curve. Now you know why NURBS curves and other splines are often described as “piece-wise curves”.</p>

<p><img src="./8 Geometry with Python_files/primer-piecewisecurve.svg" class="img-center" width="100%"></p>

<p>The shape of the red piece is entirely dictated by the first four control points. In fact, since this is a D3 curve, every piece is defined by four control points. So the second (orange) piece is defined by points {A; B; C; D}. The big difference between these pieces and a traditional Bézier curve is that the pieces stop short of the local control polygon. Instead of going all the way to {D}, the orange piece terminates somewhere in the vicinity of {C} and gives way to the green piece. Due to the mathematical magic of spline curves, the orange and green pieces fit perfectly, they have an identical position, tangency and curvature at point 4.</p>

<p>As you may or may not have guessed at this point, the little circles between pieces represent the knot-vector of this curve. This D3 curve has ten control points and twelve knots (0~11). This is not a coincidence, the number of knots follows directly from the number of points and the degree:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-96" style="width: 10.556em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.66em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.283em, 1008.56em, 2.615em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-97"><span class="msubsup" id="MathJax-Span-98"><span style="display: inline-block; position: relative; width: 1.539em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-99" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="mi" id="MathJax-Span-100" style="font-size: 70.7%; font-family: MathJax_Math-italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-101" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="msubsup" id="MathJax-Span-102" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 1.335em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.77em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-103" style="font-family: MathJax_Math-italic;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.669em;"><span class="mi" id="MathJax-Span-104" style="font-size: 70.7%; font-family: MathJax_Math-italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-105" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mo" id="MathJax-Span-106" style="font-family: MathJax_Main; padding-left: 0.207em;">(</span><span class="mi" id="MathJax-Span-107" style="font-family: MathJax_Math-italic;">D</span><span class="mo" id="MathJax-Span-108" style="font-family: MathJax_Main; padding-left: 0.207em;">−</span><span class="mn" id="MathJax-Span-109" style="font-family: MathJax_Main; padding-left: 0.207em;">1</span><span class="mo" id="MathJax-Span-110" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>K</mi><mi>N</mi></msub><mo>=</mo><msub><mi>P</mi><mi>N</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mi>D</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-3">K_N = P_N + (D-1)</script>

<p>Where <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-111" style="width: 1.898em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.539em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.54em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-112"><span class="texatom" id="MathJax-Span-113"><span class="mrow" id="MathJax-Span-114"><span class="msubsup" id="MathJax-Span-115"><span style="display: inline-block; position: relative; width: 1.539em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-116" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="mi" id="MathJax-Span-117" style="font-size: 70.7%; font-family: MathJax_Math-italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><msub><mi>K</mi><mi>N</mi></msub></mrow></math></span></span><script type="math/tex" id="MathJax-Element-4">{K_N}</script> is the knot count, <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-5-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;msub&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-118" style="width: 1.642em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.335em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.34em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-119"><span class="texatom" id="MathJax-Span-120"><span class="mrow" id="MathJax-Span-121"><span class="msubsup" id="MathJax-Span-122"><span style="display: inline-block; position: relative; width: 1.335em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.77em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-123" style="font-family: MathJax_Math-italic;">P<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.669em;"><span class="mi" id="MathJax-Span-124" style="font-size: 70.7%; font-family: MathJax_Math-italic;">N<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><msub><mi>P</mi><mi>N</mi></msub></mrow></math></span></span><script type="math/tex" id="MathJax-Element-5">{P_N}</script> is the point count and <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-125" style="width: 1.027em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.822em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1000.82em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-126"><span class="texatom" id="MathJax-Span-127"><span class="mrow" id="MathJax-Span-128"><span class="mi" id="MathJax-Span-129" style="font-family: MathJax_Math-italic;">D</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>D</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-6">{D}</script> is the degree.</p>

<p>In the image on the previous page, the red and purple pieces do in fact touch the control polygon at the beginning and end, but we have to make some effort to stretch them this far. This effort is called “clamping”, and it is achieved by stacking a lot of knots together. You can see that the number of knots we need to collapse in order to get the curve to touch a control-point is the same as the degree of the curve:</p>

<p><img src="./8 Geometry with Python_files/primer-curveknot.svg" class="img-center" width="100%"></p>

<p>A clamped curve always has a bunch of knots at the beginning and end (periodic curves do not, but we’ll get to that later). If a curve has knot clusters on the interior as well, then it will touch one of the interior control points and we have a kinked curve. There is a lot more to know about knots, but I suggest we continue with some simple nurbs curves and let Rhino worry about the knot vector for the time being.</p>

<h3 id="871-control-point-curves">8.7.1 Control-point curves</h3>

<p><img src="./8 Geometry with Python_files/primer-filletcorners.svg" alt="/images/primer-filletcorners.svg" class="float-img-right" width="275"></p>

<p>The _FilletCorners command in Rhino puts filleting arcs across all sharp kinks in a polycurve. Since fillet curves are tangent arcs, the corners have to be planar. All flat curves though can always be filleted as the image to the right shows.</p>

<p>The input curve {A} has nine G0 corners (filled circles) which qualify for a filleting operation and three G1 corners (empty circles) which do not. Since each segment of the polycurve has a length larger than twice the fillet radius, none of the fillets overlap and the result is a predictable curve {B}.</p>

<p>Since blend curves are freeform they are allowed to twist and curl as much as they please. They have no problem with non-planar segments. Our assignment for today is to make a script which inserts blend corners into polylines. We’re not going to handle polycurves (with freeform curved segments) since that would involve quite a lot of math and logic which goes beyond this simple curve introduction. This unfortunately means we won’t actually be making non-planar blend corners.</p>

<p>The logic of our BlendCorners script is simple:</p>

<ul>
  <li>Iterate though all segments of the polyline.</li>
  <li>From the beginning of the segment <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-130" style="width: 0.976em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.771em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.335em, 1000.77em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-131"><span class="texatom" id="MathJax-Span-132"><span class="mrow" id="MathJax-Span-133"><span class="mi" id="MathJax-Span-134" style="font-family: MathJax_Math-italic;">A</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>A</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-7">{A}</script>, place an extra control point <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-135" style="width: 1.693em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.386em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.39em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-136"><span class="texatom" id="MathJax-Span-137"><span class="mrow" id="MathJax-Span-138"><span class="msubsup" id="MathJax-Span-139"><span style="display: inline-block; position: relative; width: 1.386em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1001.03em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-140" style="font-family: MathJax_Math-italic;">W<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.925em;"><span class="mn" id="MathJax-Span-141" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><msub><mi>W</mi><mn>1</mn></msub></mrow></math></span></span><script type="math/tex" id="MathJax-Element-8">{W_1}</script> at distance <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-142" style="width: 0.976em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.771em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1000.77em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-143"><span class="texatom" id="MathJax-Span-144"><span class="mrow" id="MathJax-Span-145"><span class="mi" id="MathJax-Span-146" style="font-family: MathJax_Math-italic;">R</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>R</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-9">{R}</script>.</li>
  <li>From the end of the segment <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-10-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-147" style="width: 0.976em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.771em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1000.77em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-148"><span class="texatom" id="MathJax-Span-149"><span class="mrow" id="MathJax-Span-150"><span class="mi" id="MathJax-Span-151" style="font-family: MathJax_Math-italic;">B</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>B</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-10">{B}</script>, place an extra control point <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-11-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-152" style="width: 1.693em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.386em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1001.39em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-153"><span class="texatom" id="MathJax-Span-154"><span class="mrow" id="MathJax-Span-155"><span class="msubsup" id="MathJax-Span-156"><span style="display: inline-block; position: relative; width: 1.386em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1001.03em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-157" style="font-family: MathJax_Math-italic;">W<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.925em;"><span class="mn" id="MathJax-Span-158" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><msub><mi>W</mi><mn>2</mn></msub></mrow></math></span></span><script type="math/tex" id="MathJax-Element-11">{W_2}</script> at distance <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-12-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-159" style="width: 0.976em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.771em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1000.77em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-160"><span class="texatom" id="MathJax-Span-161"><span class="mrow" id="MathJax-Span-162"><span class="mi" id="MathJax-Span-163" style="font-family: MathJax_Math-italic;">R</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.003em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>R</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-12">{R}</script>.</li>
  <li>Put extra control-points halfway between <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-13-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;;&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-164" style="width: 6.816em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.587em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.335em, 1005.59em, 2.564em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-165"><span class="texatom" id="MathJax-Span-166"><span class="mrow" id="MathJax-Span-167"><span class="mi" id="MathJax-Span-168" style="font-family: MathJax_Math-italic;">A</span><span class="mo" id="MathJax-Span-169" style="font-family: MathJax_Main;">;</span><span class="msubsup" id="MathJax-Span-170" style="padding-left: 0.156em;"><span style="display: inline-block; position: relative; width: 1.386em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1001.03em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-171" style="font-family: MathJax_Math-italic;">W<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.925em;"><span class="mn" id="MathJax-Span-172" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-173" style="font-family: MathJax_Main;">;</span><span class="msubsup" id="MathJax-Span-174" style="padding-left: 0.156em;"><span style="display: inline-block; position: relative; width: 1.386em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1001.03em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-175" style="font-family: MathJax_Math-italic;">W<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.105em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.925em;"><span class="mn" id="MathJax-Span-176" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-177" style="font-family: MathJax_Main;">;</span><span class="mi" id="MathJax-Span-178" style="font-family: MathJax_Math-italic; padding-left: 0.156em;">B</span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>A</mi><mo>;</mo><msub><mi>W</mi><mn>1</mn></msub><mo>;</mo><msub><mi>W</mi><mn>2</mn></msub><mo>;</mo><mi>B</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-13">{A; W_1; W_2; B}</script>.</li>
  <li>Insert a <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-14-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-179" style="width: 1.591em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.283em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.232em, 1001.28em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-180"><span class="msubsup" id="MathJax-Span-181"><span style="display: inline-block; position: relative; width: 1.283em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.82em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-182" style="font-family: MathJax_Math-italic;">D</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.352em; left: 0.822em;"><span class="mn" id="MathJax-Span-183" style="font-size: 70.7%; font-family: MathJax_Main;">5</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>D</mi><mn>5</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-14">D^5</script> nurbs curve using those new control points.</li>
</ul>

<p>Or, in graphic form:</p>

<p><img src="./8 Geometry with Python_files/primer-blendcurved5.svg" class="img-center" width="100%"></p>

<p>The first image shows our input curve positioned on a unit grid. The shortest segment has a length of 1.0, the longest segment a length of 6.0. If we’re going to blend all corners with a radius of 0.75 (the circles in the second image) we can see that one of the edges has a conflict of overlapping blend radii.</p>

<p>The third image shows the original control points (the filled circles) and all blend radius control points (the empty circles), positioned along every segment with a distance of {R} from its nearest neighbor The two red control points have been positioned 0.5 units away (half the segment length) from their respective neighbours.</p>

<p>Finally, the last image shows all the control points that will be added in between the existing control points. Once we have an ordered array of all control points (ordered as they appear along the original polyline) we can create a <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msup&gt;&lt;/math&gt;" role="presentation" style="position: relative;"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-184" style="width: 1.591em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.283em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.232em, 1001.28em, 2.359em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-185"><span class="msubsup" id="MathJax-Span-186"><span style="display: inline-block; position: relative; width: 1.283em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.82em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-187" style="font-family: MathJax_Math-italic;">D</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.352em; left: 0.822em;"><span class="mn" id="MathJax-Span-188" style="font-size: 70.7%; font-family: MathJax_Main;">5</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>D</mi><mn>5</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-15">D^5</script> curve using <em>rs.AddCurve()</em>.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">blendcorners</span><span class="hljs-params">()</span>:</span>
    polyline_id = rs.GetObject(<span class="hljs-string">"Polyline to blend"</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> polyline_id: <span class="hljs-keyword">return</span>
    vertices = rs.PolylineVertices(polyline_id)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> vertices: <span class="hljs-keyword">return</span>
    radius = rs.GetReal(<span class="hljs-string">"Blend radius"</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">if</span> radius <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span>

    between = <span class="hljs-keyword">lambda</span> a,b: (a+b)/<span class="hljs-number">2.0</span>
    newverts = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(vertices)<span class="hljs-number">-1</span>):
        a = vertices[i]
        b = vertices[i+<span class="hljs-number">1</span>]
        segmentlength = rs.Distance(a, b)
        vec_segment = rs.PointSubtract(b, a)
        vec_segment = rs.VectorUnitize(vec_segment)

        <span class="hljs-keyword">if</span> radius&lt;(<span class="hljs-number">0.5</span>*segmentlength):
            vec_segment = rs.VectorScale(vec_segment, radius)
        <span class="hljs-keyword">else</span>:
            vec_segment = rs.VectorScale(vec_segment, <span class="hljs-number">0.5</span>*segment_length)

        w1 = rs.VectorAdd(a, vec_segment)
        w2 = rs.VectorSubtract(b, vec_segment)
        newverts.append(a)
        newverts.append(between(a,w1))
        newverts.append(w1)
        newverts.append(between(w1,w2))
        newverts.append(w2)
        newverts.append(between(w2,b))
    newverts.append(vertices[len(vertices)<span class="hljs-number">-1</span>])
    rs.AddCurve(newverts, <span class="hljs-number">5</span>)
    rs.DeleteObject(polyline_id)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2...7</td>
<td>These calls prompt the user for a polyline, get the polyline's vertices, and then promps the user for the radius of blending. Since David Rutten is the only one allowed to be so careless as to not check for None values (and we are not David Rutten) each of these operations is followed by a failure check.</td>
</tr>
<tr>
<td>9...10</td>
<td>Sometimes, an operation that is needed within a loop results in the same values in each loop iteration. In cases like this, programs can be made much more efficient, by performing these operations before entering the loop. The variables between and <i>newverts</i> will not be used until line 25, but obtaining them here at lines 9 and 10 will make the script much more efficient.
</td>
</tr>
<tr>
<td>11</td>
<td>Begin a loop for each segment in the polyline. </td>
</tr>
<tr>
<td>12...13</td>
<td>Store <i>A</i> and <i>B</i> coordinates for easy reference.</td>
</tr>
<tr>
<td>15...21</td>
<td><i>vec_segment</i> is a scaled vector that points from <i>A</i> to <i>B</i> with a length of <i>radius</i>.
Calculate the <i>vec_segment</i> vector. Typically this vector has length <i>radius</i>, but if the current polyline segment is too short to contain two complete radii, then adjust the <i>vec_segment</i> accordingly.</td>
</tr>
<tr>
<td>23...24</td>
<td>Calculate <i>W1</i> and <i>W2</i>.</td>
</tr>
<tr>
<td>25...30</td>
<td>Store all points (except <i>B</i>) in the <i>newverts</i> list.</td>
</tr>
<tr>
<td>31</td>
<td>Append the last point of the polyline to the <i>newverts</i> list. We've omitted <i>B</i> everywhere because the <i>A</i> of the next segment has the same location and we do not want coincident control-points. The last segment has no next segment, so we need to make sure <i>B</i> is included this time.</td>
</tr>
<tr>
<td>32...33</td>
<td>Create a new D5 nurbs curve and delete the original.</td>
</tr>
</tbody></table>

<h3 id="872-interpolated-curves">8.7.2 Interpolated curves</h3>

<p>When creating control-point curves it is very difficult to make them go through specific coordinates. Even when tweaking control-points this would be an arduous task. This is why commands like <em>_HBar</em> are so important. However, if you need a curve to go through many points, you’re better off creating it using an interpolated method rather than a control-point method. The <em>_InterpCrv</em> and <em>_InterpCrvOnSrf</em> commands allow you to create a curve that intersects any number of 3D points and both of these methods have an equivalent in RhinoScriptSyntax.</p>

<p>To demonstrate, we’re going to create a script that creates iso-distance-curves on surfaces rather than the standard iso-parameter-curves, or “isocurves” as they are usually called.  Isocurves, thus connect all the points in surface space that share a similar u or v value. Because the progression of the domain of a surface is not linear (it might be compressed in some places and stretched in others, especially near the edges where the surface has to be clamped), the distance between isocurves is not guaranteed to be identical either.</p>

<p>The description of our algorithm is very straightforward, but I promise you that the actual script itself will be the hardest thing you’ve ever done.</p>

<p><img src="./8 Geometry with Python_files/primer-isocurves.svg" class="img-center" width="100%"></p>

<p>Our script will take any base surface (image A) and extract a number of isocurves (image B). Then, every isocurve is trimmed to a specific length (image C) and the end-points are connected to give the iso-distance-curve (the red curve in image D). Note that we are using isocurves in the v-direction to calculate the iso-distance-curve in the u-direction. This way, it doesn’t matter much that the spacing of isocurves isn’t distributed equally. Also note that this method is only useful for offsetting surface edges as opposed to <em>_OffsetCrvOnSrf</em> which can offset any curve.</p>

<p>We can use the RhinoScriptSytnax methods <em>rs.ExtractIsoCurve()</em> and <em>rs.AddInterpCrvOnSrf()</em> for steps B and D, but step C is going to take some further thought. It is possible to divide the extracted isocurve using a fixed length, which will give us a whole list of points, the second of which marks the proper solution:</p>

<p><img src="./8 Geometry with Python_files/python-dividecurvesearching.svg" class="img-center" width="100%"></p>

<p>In the example above, the curve has been divided into equal length segments of 5.0 units each. The red point (the second item in the collection) is the answer we’re looking for. All the other points are of no use to us, and you can imagine that the shorter the distance we’re looking for, the more redundant points we get. Under normal circumstances I would not think twice and simply use the <em>rs.DivideCurveLength()</em> method. However, I’ll take this opportunity to introduce you to one of the most ubiquitous, popular and prevalent algorithms in the field of programming today: binary searching.</p>

<p>Imagine you have a list of integers which is -say- ten thousand items long and you want to find the number closest to sixteen. If this list is unordered (as opposed to sorted) , like so:</p>

<blockquote>
  <p>{-2, -10, 12, -400, 80, 2048, 1, 10, 11, -369, 4, -500, 1548, 8, … , 13, -344}</p>
</blockquote>

<p>you have pretty much no option but to compare every item in turn and keep a record of which one is closest so far. If the number sixteen doesn’t occur in the list at all, you’ll have to perform ten thousand comparisons before you know for sure which number was closest to sixteen. This is known as a worst-case performance, the best-case performance would be a single comparison since sixteen might just happen to be the first item in the list… if you’re lucky.</p>

<p>The method described above is known as a list-search and it is a pretty inefficient way of searching a large dataset and since searching large datasets is something that we tend to do a lot in computer science, plenty research has gone into speeding things up. Today there are so many different search algorithms that we’ve had to put them into categories in order to keep a clear overview. However, pretty much all efficient searching algorithms rely on the input list being sorted, like so:</p>

<blockquote>
  <p>{-500, -400, -369, -344, -10, -2, 1, 4, 8, 10, 11, 12, 13, 80, … , 1548, 2048}</p>
</blockquote>

<p>Once we have a sorted list it is possible to improve our worst case performance by orders of magnitude. For example, consider a slightly more advanced list-search algorithm which aborts the search once results start to become worse. Like the original list-search it will start at the first item {-500}, then continue to the second item {-400}. Since {-400} is closer to sixteen than {-500}, there is every reason to believe that the next item in the list is going to be closer still. This will go on until the algorithm has hit the number thirteen. Thirteen is already pretty close to sixteen but there is still some wiggle room so we cannot be absolutely sure ({14; 15; 16; 17; 18} are all closer and {19} is equally close). However, the next number in the list is {80} which is a much, worse result than thirteen. Now, since this list is sorted we can be sure that every number after {80} is going to be worse still so we can safely abort our search knowing that thirteen is the closest number. Now, if the number we’re searching for is near the beginning of the list, we’ll have a vast performance increase, if it’s near the end, we’ll have a small performance increase. On average though, the sorted-list-search is twice as fast as the old-fashioned-list-search.</p>

<p>Binary-searching does far better. Let us return to our actual problem to see how binary-searching works; find the point on a curve that marks a specific length along the curve. In the image below, the point we are looking for has been indicated with a small yellow tag, but of course we don’t know where it is when we begin our search. Instead of starting at the beginning of the curve, we start halfway between {tmin} and {tmax} (halfway the domain of the curve). Since we can ask Rhino what the length is of a certain curve subdomain we can calculate the length from {tmin} to {1}. This happens to be way too much, we’re looking for something less than half this length. Thus we divide the bit between {tmin} and {1} in half yet again, giving us {2}. We again measure the distance between {tmin} and {2}, and see that again we’re too high, but this time only just. We keep on dividing the remainder of the domain in half until we find a value {6} which is close enough for our purposes:</p>

<p><img src="./8 Geometry with Python_files/primerbinarycurvesearching.svg" class="img-center" width="100%"></p>

<p>This is an example of the simplest implementation of a binary-search algorithm and the performance of binary searching is O(log n) which is a fancy way of saying that it’s fast. Really, really fast. And what’s more, when we enlarge the size of the collection we’re searching, the time taken to find an answer doesn’t increase in a similar fashion (as it does with list-searching). Instead, it becomes relatively faster and faster as the size of the collection grows. For example, if we double the size of the array we’re searching to 20,000 items, a list-search algorithm will take twice as long to find the answer, whereas a binary-searcher only takes ~1.075 times as long.</p>

<p>The theory of binary searching might be easy to grasp (maybe not right away, but you’ll see the beauty eventually), any practical implementation has to deal with some annoying, code-bloating aspects. For example, before we start a binary search operation, we must make sure that the answer we’re looking for is actually contained within the set. In our case, if we’re looking for a point {P} on the curve {C} which is 100.0 units away from the start of {C}, there exists no answer if {C} is shorter than 100.0 itself. Also, since we’re dealing with a parameter domain as opposed to a list of integers, we do not have an actual list showing all the possible values. This array would be too big to fit in the memory of your computer. Instead, all we have is the knowledge that any number between and including {tmin} and {tmax} is theoretically possible. Finally, there might not exist an exact answer. All we can really hope for is that we can find an answer within tolerance of the exact length. Many operations in computational geometry are tolerance bound, sometimes because of speed issues (calculating an exact answer would take far too long), sometimes because an exact answer cannot be found (there is simply no math available, all we can do is make a set of guesses each one progressively better than the last).</p>

<p>At any rate, here’s the binary-search script I came up with, I’ll deal with the inner workings afterwards:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BSearchCurve</span><span class="hljs-params">(idCrv, Length, Tolerance)</span>:</span>
    Lcrv = rs.CurveLength(idCrv)
    <span class="hljs-keyword">if</span> Lcrv&lt;Length: <span class="hljs-keyword">return</span>

    tmin = rs.CurveDomain(idCrv)[<span class="hljs-number">0</span>]
    tmax = rs.CurveDomain(idCrv)[<span class="hljs-number">1</span>]
    t0 = tmin
    t1 = tmax
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        t = <span class="hljs-number">0.5</span>*(t1+t0)
        Ltmp = rs.CurveLength(idCrv, <span class="hljs-number">0</span>, [tmin, t])
        <span class="hljs-keyword">if</span> abs(Ltmp-Length)&lt;Tolerance: <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> Ltmp&lt;Length: t0=t
        <span class="hljs-keyword">else</span>: t1 = t
    <span class="hljs-keyword">return</span> t
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>Note that this is not a complete script, it is only the search function. The complete script is supplied in the article archive. This function takes a curve ID, a desired length and a tolerance. The return value is <i>None</i> if no solution exists (i.e. if the curve is shorter than <i>Length</i>) or otherwise the parameter that marks the desired length.</td>
</tr>
<tr>
<td>2</td>
<td>Ask Rhino for the total curve length.
</td>
</tr>
<tr>
<td>3</td>
<td>Make sure the curve is longer than <i>Length</i>. If it isn't, abort.</td>
</tr>
<tr>
<td>5...6</td>
<td>Store the minimum and maximum parameters of this curve domain. If you're confused about me calling the <i>Rhino.CurveDomain()</i> function twice instead of just once and store the resulting array, you may congratulate yourself. It would indeed be faster to not call the same method twice in a row. However, since lines 7 and 8 are not inside a loop, they will only execute once which reduces the cost of the penalty. 99% of the time spend by this function is because of lines 16~25, if we're going to be zealous about speed, we should focus on this part of the code.</td>
</tr>
<tr>
<td>7...8</td>
<td><i>t0</i>, <i>t1</i> and <i>t</i> will be the variables used to define our current subdomain. <i>t0</i> will mark the lower bound and <i>t1</i> the upper bound. <i>t</i> will be halfway between <i>t0</i> and <i>t1</i>. We need to start with the whole curve in mind, so <i>t0</i> and <i>t1</i> will be similar to <i>tmin</i> and <i>tmax</i>.</td>
</tr>
<tr>
<td>9</td>
<td>Since we do not know in advance how many steps our binary searcher is going to take, we have to use an infinite loop.</td>
</tr>
<tr>
<td>10</td>
<td>Calculate <i>t</i> always exactly in the middle of {<i>t0</i>, <i>t1</i>}.</td>
</tr>
<tr>
<td>11</td>
<td>Calculate the length of the subcurve from the start of the curve (<i>tmin</i>) to our current parameter (<i>t</i>).</td>
</tr>
<tr>
<td>12</td>
<td>If this length is close enough to the desired length, then we are done and we can abort the infinite loop. <i>abs()</i> -in case you were wondering- is a Python function that returns the absolute (non-negative) value of a number. This means that the <i>tolerance</i> argument works equally strong in both directions, which is what you'd usually want.</td>
</tr>
<tr>
<td>13...14</td>
<td>This is the magic bit. Looks harmless enough doesn't it?
What we do here is adjust the subdomain based on the result of the length comparison. If the length of the subcurve {<i>tmin</i>, <i>t</i>} is shorter than <i>Length</i>, then we want to restrict ourself to the lower half of the old subdomain. If, on the other hand, the subcurve length is shorter than <i>Length</i>, then we want the upper half of the old domain.
Notice how much more compact programming code is compared to English?</td>
</tr>
<tr>
<td>15</td>
<td>Return the solved <i>t</i>-parameter.</td>
</tr>
</tbody></table>

<p>I have unleashed this function on a smooth curve with a fairly well distributed parameter space (i.e. no sudden jumps in parameter “density”) and the results are listed below. The length of the total curve was 200.0 mm and I wanted to find the parameter for a subcurve length of 125.0 mm. My tolerance was set to 0.0001 mm. As you can see it took 18 refinement steps in the <em>BSearchCurve()</em> function to find an acceptable solution. Note how fast this algorithm homes in on the correct value, after just 6 steps the remaining error is less than 1%. Ideally, with every step the accuracy of the guess is doubled, in practise however you’re unlikely to see such a neat progression. In fact, if you closely examine the table, you’ll see that sometimes the new guess overshoots the solution so much it actually becomes worse than before (like between steps #9 and #10).</p>

<p>I’ve greyed out the subdomain bound parameters that remained identical between two adjacent steps. You can see that sometimes multiple steps in the same direction are required.</p>

<p><img src="./8 Geometry with Python_files/primer-subdivisionchart.svg" class="img-center" width="100%"></p>

<p>Now for the rest of the script as outlines on page 78:</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equidistanceoffset</span><span class="hljs-params">()</span>:</span>
    srf_id = rs.GetObject(<span class="hljs-string">"Pick surface to offset"</span>, <span class="hljs-number">8</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> srf_id: <span class="hljs-keyword">return</span>

    offset = rs.GetReal(<span class="hljs-string">"Offset distance"</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> offset: <span class="hljs-keyword">return</span>

    udomain = rs.SurfaceDomain(srf_id, <span class="hljs-number">0</span>)
    ustep = (udomain[<span class="hljs-number">1</span>]-udomain[<span class="hljs-number">0</span>])/<span class="hljs-number">200</span>
    rs.EnableRedraw(<span class="hljs-keyword">False</span>)

    offsetvertices = []
    u = udomain[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">while</span> u&lt;=(udomain[<span class="hljs-number">1</span>]+<span class="hljs-number">0.5</span>*ustep):
        isocurves = rs.ExtractIsoCurve(srf_id, (u,<span class="hljs-number">0</span>), <span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> isocurves:
            t = BSearchCurve(isocurves[<span class="hljs-number">0</span>], offset, <span class="hljs-number">0.001</span>)
            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                offsetvertices.append(rs.EvaluateCurve(isocurves[<span class="hljs-number">0</span>], t))
            rs.DeleteObjects(isocurves)
        u+=ustep

    <span class="hljs-keyword">if</span> offsetvertices: rs.AddInterpCrvOnSrf(srf_id, offsetvertices)
    rs.EnableRedraw(<span class="hljs-keyword">True</span>)
</code></pre>
<p><img src="./8 Geometry with Python_files/primer-equidistantoffset-result.svg" alt="/images/primer-equidistantoffset-result.svg" class="float-img-right" width="375"></p>

<p>If I’ve done my job so far, the above shouldn’t require any explanation. All of it is straight forward scripting code.</p>

<p>The image on the right shows the result of the script, where offset values are all multiples of 10. The dark green lines across the green strip (between offsets 80.0 and 90.0)  are all exactly 10.0 units long.</p>

<p>&nbsp;</p>

<h3 id="873-geometric-curve-properties">8.7.3 Geometric curve properties</h3>

<p>Since curves are geometric objects, they possess a number of properties or characteristics which can be used to describe or analyze them. For example, every curve has a starting coordinate and every curve has an ending coordinate. When the distance between these two coordinates is zero, the curve is closed. Also, every curve has a number of control-points, if all these points are located in the same plane, the curve as a whole is planar. Some properties apply to the curve as a whole, others only apply to specific points on the curve. For example, planarity is a global property while tangent vectors are a local property. Also, some properties only apply to some curve types. So far we’ve dealt with lines, polylines, circles, ellipses, arcs and nurbs curves:</p>

<p><img src="./8 Geometry with Python_files/primer-curvetypes.svg" class="img-center" width="100%"></p>

<p>The last available curve type in Rhino is the polycurve, which is nothing more than an amalgamation of other types. A polycurve can be a series of line curves for example, in which case it behaves similarly to a polyline. But it can also be a combination of lines, arcs and nurbs curves with different degrees. Since all the individual segments have to touch each other (G0 continuity is a requirement for polycurve segments), polycurves cannot contain closed segments. However, no matter how complex the polycurve, it can always be represented by a nurbs curve. All of the above types can be represented by a nurbs curve.</p>

<p>The difference between an actual circle and a nurbs-curve-that-looks-like-a-circle is the way it is stored. A nurbs curve doesn’t have a Radius property for example, nor a Plane in which it is defined. It is possible to reconstruct these properties by evaluating derivatives and tangent vector and frames and so on and so forth, but the data isn’t readily available. In short, nurbs curves lack some global properties that other curve types do have. This is not a big issue, it’s easy to remember what properties a nurbs curve does and doesn’t have. It is much harder to deal with local properties that are not continuous. For example, imagine a polycurve which has a zero-length line segment embedded somewhere inside. The t-parameter at the line beginning is a different value from the t-parameter at the end, meaning we have a curve subdomain which has zero length. It is impossible to calculate a normal vector inside this domain:</p>

<p><img src="./8 Geometry with Python_files/primer-polycurvecompound.svg" class="img-center" width="100%"></p>

<p>This polycurve consists of five curve segments (a nurbs-curve, a zero-length line-segment, a proper line-segment, a 90° arc and another nurbs-curve respectively) all of which touch each other at the indicated t-parameters. None of them are tangency continuous, meaning that if you ask for the tangent at parameter {t<sub>3</sub>}, you might either get the tangent at the end of the purple segment or the tangent at the beginning of the green segment. However, if you ask for the tangent vector halfway between {t<sub>1</sub>} and {t<sub>2</sub>}, you get nothing. The curvature data domain has an even bigger hole in it, since both line-segments lack any curvature:</p>

<p><img src="./8 Geometry with Python_files/primer-polycurvelocalevaluation.svg" class="img-center" width="100%"></p>

<p>When using curve properties such as tangents, curvature or perp-frames, we must always be careful to not blindly march on without checking for property discontinuities. An example of an algorithm that has to deal with this would be the <em>_CurvatureGraph</em> in Rhino. It works on all curve types, which means it must be able to detect and ignore linear and zero-length segments that lack curvature.</p>

<p>One thing the <em>_CurvatureGraph</em> command does not do is insert the curvature graph objects, it only draws them on the screen. We’re going to make a script that inserts the curvature graph as a collection of lines and interpolated curves. We’ll run into several issues already outlined in this paragraph.</p>

<p>In order to avoid some <em>G</em> continuity problems we’re going to tackle the problem span by span. In case you haven’t suffered left-hemisphere meltdown yet; the shape of every knot-span is determined by a certain mathematical function known as a polynomial and is (in most cases) completely smooth. A span-by-span approach means breaking up the curve into its elementary pieces, as shown on the left:</p>

<p><img src="./8 Geometry with Python_files/primer-polycurvecurvaturegraph.svg" class="img-center" width="100%"></p>

<p>This is a polycurve object consisting of seven pieces; lines {A; C; E}, arcs {B; D} and nurbs curves {F; G}. When we convert the polycurve to a nurbs representation we get a degree 5 nurbs curve with 62 pieces (knot-spans). Since this curve was made by joining a bunch of other curves together, there are kinks between all individual segments. A kink is defined as a grouping of identical knots on the interior of a curve, meaning that the curve actually intersects one of its interior control-points. A kink therefore has the potential to become a sharp crease in an otherwise smooth curve, but in our case all kinks connect segments that are G1 continuous. The kinks have been marked by white circles in the image on the right. As you can see there are also kinks in the middle of the arc segments {B; D}, which were there before we joined the curves together. In total this curve has ten kinks, and every kink is a grouping of five similar knot parameters (this is a D<sup>5</sup> curve). Thus we have a sum-total of 40 zero-length knot-spans. Never mind about the math though, the important thing is that we should prepare for a bunch of zero-length spans so we can ignore them upon confrontation.</p>

<p>The other problem we’ll get is the property evaluation issue I talked about on the previous page. On the transition between knots the curvature data may jump from one value to another. Whenever we’re evaluating curvature data near knot parameters, we need to know if we’re coming from the left or the right.</p>

<p>I’m sure all of this sounds terribly complicated. In fact, I’m sure it is terribly complicated, but these things should start to make sense. It is no longer enough to understand how scripts work under ideal circumstances, by now, you should understand why there are no ideal circumstances and how that affects programming code.</p>

<p>Since we know exactly what we need to do in order to mimic the <em>_CurvatureGraph</em> command, we might as well start at the bottom. The first thing we need is a function that creates a curvature graph on a subcurve, then we can call this function with the knot parameters as sub-domains in order to generate a graph for the whole curve:</p>

<p><img src="./8 Geometry with Python_files/primer-spancurvaturegraph.svg" class="img-center" width="100%"></p>

<p>Our function will need to know the ID of the curve in question, the subdomain {t<sub>0</sub>; t<sub>1</sub>}, the number of samples it is allowed to take in this domain and the scale of the curvature graph. The return value should be a collection of object IDs which were inserted to make the graph. This means all the perpendicular red segments and the  dashed black curve connecting them.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addcurvaturegraphsection</span><span class="hljs-params">(idCrv, t0, t1, samples, scale)</span>:</span>
    <span class="hljs-keyword">if</span> (t1-t0)&lt;=<span class="hljs-number">0.0</span>: <span class="hljs-keyword">return</span>
    tstep = (t1-t0)/samples
    points = []
    objects = []
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> rs.frange(t0,t1+(<span class="hljs-number">0.5</span>*tstep),tstep):
        <span class="hljs-keyword">if</span> t&gt;=t1:t = t1<span class="hljs-number">-1e-10</span>
        cData = rs.CurveCurvature(idCrv, t)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cData:
            points.append(rs.EvaluateCurve(idCrv, t))
        <span class="hljs-keyword">else</span>:
            c = rs.VectorScale(cData[<span class="hljs-number">4</span>], scale)
            a = cData[<span class="hljs-number">0</span>]
            b = rs.VectorSubtract(a, c)
            objects.append(rs.AddLine(a,b))
            points.append(b)

    objects.append(rs.AddInterpCurve(points))
    <span class="hljs-keyword">return</span> objects
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2</td>
<td>Check for a null span, this happens inside kinks.</td>
</tr>
<tr>
<td>3</td>
<td>Determine a step size for our loop (Subdomain length / Sample count).
</td>
</tr>
<tr>
<td>5</td>
<td><i>objects()</i> will hold the IDs of the perpendicular lines, and the connecting curve.</td>
</tr>
<tr>
<td>6</td>
<td>Define the loop and make sure we always process the final parameter by increasing the threshold with half the step size.</td>
</tr>
<tr>
<td>7</td>
<td>Make sure <i>t</i> does not go beyond <i>t1</i>, since that might give us the curvature data of the next segment.</td>
</tr>
<tr>
<td>10</td>
<td>In case of a curvature data discontinuity, do not add a line segment but append the point on the curve at the current curve coordinate <i>t</i>.</td>
</tr>
<tr>
<td>12...16</td>
<td>Compute the A and B coordinates, append them to the appropriate array and add the line segment.</td>
</tr>
</tbody></table>

<p>Now, we need to write a utility function that applies the previous function to an entire curve. There’s no rocket science here, just an iteration over the knot-vector of a curve object:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addcurvaturegraph</span><span class="hljs-params">( idCrv, spansamples, scale)</span>:</span>
    allGeometry = []
    knots = rs.CurveKnots(idCrv)
    p=<span class="hljs-number">5</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(knots)<span class="hljs-number">-1</span>):
        tmpGeometry = addcurvaturegraphsection(idCrv, knots[i], knots[i+<span class="hljs-number">1</span>], spansamples, scale)
        <span class="hljs-keyword">if</span> tmpGeometry: allGeometry.append(tmpGeometry)
    rs.AddObjectsToGroup(allGeometry, rs.AddGroup())
    <span class="hljs-keyword">return</span> allGeometry
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2</td>
<td><i>allGeometry</i> will be a list of all IDs generated by repetitive calls to <i>AddCurvatureGraphSection()</i></td>
</tr>
<tr>
<td>3</td>
<td><i>knots</i> is the knot vector of the nurbs representation of <i>idCrv</i>.
</td>
</tr>
<tr>
<td>5</td>
<td>We want to iterate over all knot spans, meaning we have to iterate over all (except the last) knot in the knot vector. Hence the minus one at the end.</td>
</tr>
<tr>
<td>6</td>
<td>Place a call to <i>addcurvaturegraphsection()</i> and store all resulting IDs in <i>tmpGeometry</i>.</td>
</tr>
<tr>
<td>7</td>
<td>If the result of <i>AddCurvatureGraphSection()</i> is not <i>Null</i>, then append all items in <i>tmpGeometry</i> to <i>allGeometry</i>.</td>
</tr>
<tr>
<td>8</td>
<td>Put all created objects into a new group.</td>
</tr>
</tbody></table>

<p>The last bit of code we need to write is a bit more extensive than we’ve done so far. Until now we’ve always prompted for a number of values before we performed any action. It is actually far more user-friendly to present the different values as options in the command line while drawing a preview of the result.</p>

<p>UI code tends to be very beefy, but it rarely is complex. It’s just irksome to write because it always looks exactly the same. In order to make a solid command-line interface for your script you have to do the following:</p>

<ul>
  <li>Reserve a place where you store all your preview geometry</li>
  <li>Initialize all settings with sensible values</li>
  <li>Create all preview geometry using the default settings</li>
  <li>Display the command line options</li>
  <li>Parse the result (be it escape, enter or an option or value string)</li>
  <li>Select case through all your options</li>
  <li>If the selected option is a setting (as opposed to options like “Cancel” or “Accept”) then display a prompt for that setting</li>
  <li>Delete all preview geometry</li>
  <li>Generate new preview geometry using the changed settings.</li>
</ul>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createcurvaturegraph</span><span class="hljs-params">()</span>:</span>
    curve_ids = rs.GetObjects(<span class="hljs-string">"Curves for curvature graph"</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> curve_ids: <span class="hljs-keyword">return</span>

    samples = <span class="hljs-number">10</span>
    scale = <span class="hljs-number">1.0</span>

    preview = []
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        rs.EnableRedraw(<span class="hljs-keyword">False</span>)
        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> preview: rs.DeleteObjects(p)
        preview = []
        <span class="hljs-keyword">for</span> id <span class="hljs-keyword">in</span> curve_ids:
            cg = addcurvaturegraph(id, samples, scale)
            preview.append(cg)
        rs.EnableRedraw(<span class="hljs-keyword">True</span>)

        result = rs.GetString(<span class="hljs-string">"Curvature settings"</span>, <span class="hljs-string">"Accept"</span>, (<span class="hljs-string">"Samples"</span>, <span class="hljs-string">"Scale"</span>, <span class="hljs-string">"Accept"</span>))
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:
            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> preview: rs.DeleteObjects(p)
            <span class="hljs-keyword">break</span>
        result = result.upper()
        <span class="hljs-keyword">if</span> result==<span class="hljs-string">"ACCEPT"</span>: <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"SAMPLES"</span>:
            numsamples = rs.GetInteger(<span class="hljs-string">"Number of samples per knot-span"</span>, samples, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>)
            <span class="hljs-keyword">if</span> numsamples: samples = numsamples
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"SCALE"</span>:
            sc = rs.GetReal(<span class="hljs-string">"Scale of the graph"</span>, scale, <span class="hljs-number">0.01</span>, <span class="hljs-number">1000.0</span>)
            <span class="hljs-keyword">if</span> sc: scale = sc
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2</td>
<td>Prompt for any number of curves, we do not want to limit our script to just one curve.</td>
</tr>
<tr>
<td>5...6</td>
<td>Our default values are a scale factor of 1.0 and a span sampling count of 10.
</td>
</tr>
<tr>
<td>8</td>
<td><i>preview()</i> is a list that contains arrays of IDs. One for each curve in <i>idCurves</i>.</td>
</tr>
<tr>
<td>9</td>
<td>Since users are allowed to change the settings an infinite number of times, we need an infinite loop around our UI code.</td>
</tr>
<tr>
<td>10...11</td>
<td>First of all, delete all the preview geometry, if present.</td>
</tr>
<tr>
<td>13...15</td>
<td>Then, insert all the new preview geometry.</td>
</tr>
<tr>
<td>28</td>
<td>Once the new geometry is in place, display the command options. The array at the end of the <i>rs.GetString()</i> method is a list of command options that will be visible.</td>
</tr>
<tr>
<td>19...21</td>
<td>If the user aborts (pressed Escape), we have to delete all preview geometry and exit the sub.</td>
</tr>
<tr>
<td>23...29</td>
<td>If the user clicks on an option, <i>result</i> will be the option name. The best method IronPython implements to treat the choice is the <i>If...Then</i> statement shown.</td>
</tr>
<tr>
<td>23</td>
<td>In the case of "Accept", all we have to do is exit the sub without deleting the preview geometry.</td>
</tr>
<tr>
<td>24...26</td>
<td>If the picked option was "Samples", then we have to ask the user for a new sample count. If the user pressed Escape during this nested prompt, we do not abort the whole script (typical Rhino behaviour would dictate this), but instead return to the base prompt.</td>
</tr>
<tr>
<td>27...29</td>
<td>If the picked option was "Scale", then we have to ask the user for a new scale factor, and . If the user pressed Escape during this nested prompt, we do not abort the whole script (typical Rhino behaviour would dictate this), but instead return to the base prompt.</td>
</tr>
</tbody></table>

<h2 id="88-meshes">8.8 Meshes</h2>

<p>Instead of Nurbs surfaces (which would be the next logical step after nurbs curves), this chapter is about meshes. I’m going to take this opportunity to introduce you to a completely different class of geometry -officially called “polygon meshes”- which represents a radically different approach to shape.</p>

<p>Instead of treating a surface as a deformation of a rectangular nurbs patch, meshes are defined locally, which means that a single mesh surface can have any topology it wants. A mesh surface can even be a disjoint (not connected) compound of floating surfaces, something which is absolutely impossible with Rhino nurbs surfaces. Because meshes are defined locally, they can also store more information directly inside the mesh format, such as colors, texture-coordinates and normals. The tantalizing image below indicates the local properties that we can access via RhinoScriptSyntax. Most of these properties are optional or have default values. The only essential ones are the vertices and the faces.</p>

<p><img src="./8 Geometry with Python_files/primer-meshtopology.svg" class="img-center" width="80%"></p>

<p>It is important to understand the pros and cons of meshes over alternative surface paradigms, so you can make an informed decision about which one to use for a certain task. Most differences between meshes and nurbs are self-evident and flow from the way in which they are defined. For example, you can delete any number of polygons from the mesh and still have a valid object, whereas you cannot delete knot spans without breaking apart the nurbs geometry. There’s a number of things to consider which are not implied directly by the theory though.</p>

<ul>
  <li>Coordinates of mesh vertices are stored as single precision numbers in Rhino in order to save memory consumption. Meshes are therefore less accurate entities than nurbs objects. This is especially notable with objects that are very small, extremely large or very far away from the world origin. Mesh objects go hay-wire sooner than nurbs objects because single precision numbers have larger gaps between them than double precision numbers (see page 6).</li>
  <li>Nurbs cannot be shaded, only the isocurves and edges of nurbs geometry can be drawn directly in the viewport. If a nurbs surface has to be shaded, then it has to fall back on meshes. This means that inserting nurbs surfaces into a shaded viewport will result in a significant (sometimes very significant) time lag while a mesh representation is calculated.</li>
  <li>Meshes in Rhino can be non-manifold, meaning that more than two faces share a single edge. Although it is not technically impossible for nurbs to behave in this way, Rhino does not allow it. Non-manifold shapes are topologically much harder to deal with. If an edge belongs to only a single face it is an exterior edge (naked), if it belongs to two faces it is considered interior.</li>
</ul>

<h3 id="881-geometry-vs-topology">8.8.1 Geometry vs. Topology</h3>

<p>As mentioned before, only the vertices and faces are essential components of the mesh definition. The vertices represent the geometric part of the mesh definition, the faces represent the topological part. Chances are you have no idea what I’m talking about… allow me to explain.</p>

<p>According to MathWorld.com topology is “<em>the mathematical study of the properties that are preserved through deformations, twistings, and stretching of objects.</em>” In other words, topology doesn’t care about size, shape or smell, it only deals with the platonic properties of objects, such as “how many holes does it have?”, “how many naked edges are there?” and “how do I get from Paris to Lyon without passing any tollbooths?”. The field of topology is partly common-sense (everybody intuitively understands the basics) and partly abstract-beyond-comprehension. Luckily we’re only confronted with the intuitive part here.</p>

<p><img src="./8 Geometry with Python_files/primer-topology.svg" class="img-center" width="80%"></p>

<p>If you look at the images above, you’ll see a number of surfaces that are topologically identical (except {E}) but geometrically different. You can bend shape {A} and end up with shape {B}; all you have to do is reposition some of the vertices. Then if you bend it even further you get {C} and eventually {D} where the right edge has been bend so far it touches the edge on the opposite side of the surface. It is not until you merge the edges
(shape {E}) that this shape suddenly changes its platonic essence, i.e. it goes from a shape with four edges to a shape with only two edges (and these two remaining edges are now closed loops as well). Do note that shapes {D} and {E} are geometrically identical, which is perhaps a little surprising.</p>

<p>The vertices of a mesh object are a list of 3D point coordinates. They can be located anywhere in space and they control the size and form of the mesh. The faces on the other hand do not contain any coordinate data, they merely indicate how the vertices are to be connected:</p>

<p><img src="./8 Geometry with Python_files/primer-connected.svg" class="img-center" width="100%"></p>

<p>Here you see a very simple mesh with sixteen vertices and nine faces. Commands like <em>_Scale</em>, <em>_Move</em> and <em>_Bend</em> only affect the vertex-list, commands like <em>_TriangulateMesh</em> and <em>_SwapMeshEdge</em> only affect the face-list, commands like <em>_ReduceMesh</em> and <em>_MeshTrim</em> affect both lists. Note that the last face {<em>I</em>} has its corners defined in a clockwise fashion, whereas all the other faces are defined counter-clockwise. Although this makes no geometric difference, it does affect how the mesh normals are calculated and one should generally avoid creating meshes that are cw/ccw inconsistent.</p>

<p>Now that we know what meshes essentially consist of, we can start making mesh shapes from scratch. All we need to do is come up with a set of matching vertex/face arrays. We’ll start with the simplest possible shape, a mesh plane consisting of a grid of vertices connected with quads. Just to keep matters marginally interesting, we’ll mutate the z-coordinates of the grid points using a user-specified mathematical function in the form of:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-16-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x0398;&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x0394;&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-189" style="width: 9.121em; display: inline-block;"><span style="display: inline-block; position: relative; width: 7.482em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.283em, 1007.38em, 2.615em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-190"><span class="mi" id="MathJax-Span-191" style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span class="mo" id="MathJax-Span-192" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-193" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-194" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-195" style="font-family: MathJax_Math-italic; padding-left: 0.156em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-196" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-197" style="font-family: MathJax_Main; padding-left: 0.156em;">Θ</span><span class="mo" id="MathJax-Span-198" style="font-family: MathJax_Main;">,</span><span class="mi" id="MathJax-Span-199" style="font-family: MathJax_Main; padding-left: 0.156em;">Δ</span><span class="mo" id="MathJax-Span-200" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-201" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mo" id="MathJax-Span-202" style="font-family: MathJax_Main;">.</span><span class="mo" id="MathJax-Span-203" style="font-family: MathJax_Main; padding-left: 0.156em;">.</span><span class="mo" id="MathJax-Span-204" style="font-family: MathJax_Main; padding-left: 0.156em;">.</span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi mathvariant="normal">Θ</mi><mo>,</mo><mi mathvariant="normal">Δ</mi><mo stretchy="false">)</mo><mo>=</mo><mo>.</mo><mo>.</mo><mo>.</mo></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-16">f(x, y, \Theta, \Delta) = ...</script>

<p><img src="./8 Geometry with Python_files/primer-meshgraph_xy.svg" alt="/imagesprimer-meshgraph_xy.svg" class="float-img-right" width="375"></p>

<p>Where the user is allowed to specify any valid mathematical function using the variables <em>x</em>, <em>y</em>, <em>Θ</em> and <em>Δ</em>. Every vertex in the mesh plane has a unique combination of <em>x</em> and <em>y</em> values which can be used to determine the <em>z</em> value of that vertex by evaluating the custom function (<em>Θ</em> and <em>Δ</em> are the polar coordinates of <em>x</em> and <em>y</em>). This means every vertex {A} in the plane has a coordinate {B} associated with it which shares the <em>x</em> and <em>y</em> components, but not the <em>z</em> component.</p>

<p>We’ll run into four problems while writing this script which we have not encountered before, but only two of these have to do with mesh geometry/topology:</p>

<p>It’s easy enough to generate a grid of points, we’ve done similar looping before where a nested loop was used to generate a grid wrapped around a cylinder. The problem this time is that it’s not enough to generate the points. We also have to generate the face-list, which is highly dependent on the row and column dimensions of the vertex list. It’s going to take a lot of logic insight to get this right (probably easiest to make a schematic first). Let us turn to the problem of generating the vertex coordinates, which is a straightforward one:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createmeshvertices</span><span class="hljs-params">(function, fdomain, resolution)</span>:</span>
    xstep = (fdomain[<span class="hljs-number">1</span>]-fdomain[<span class="hljs-number">0</span>])/resolution
    ystep = (fdomain[<span class="hljs-number">3</span>]-fdomain[<span class="hljs-number">2</span>])/resolution
    v = []
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rs.frange(fdomain[<span class="hljs-number">0</span>],fdomain[<span class="hljs-number">1</span>]+(<span class="hljs-number">0.5</span>*xstep), xstep):
        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> rs.frange(fdomain[<span class="hljs-number">2</span>],fdomain[<span class="hljs-number">3</span>]+(<span class="hljs-number">0.5</span>*ystep),ystep):
            z = solveequation(function, x, y)
            v.append( (x,y,z) )
    <span class="hljs-keyword">return</span> v
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>This function is to be part of the finished script. It is a very specific function which merely combines the logic of nested loops with other functions inside the same script (functions which we haven't written yet, but since we know how they are supposed to work we can pretend as though they are available already). This function takes three arguments:
<ol>
<li>A String variable which contains the format of the function {f(x,y,Θ,Δ) = …}</li>
<li>An array of four doubles, indicating the domain of the function in x and y directions</li>
<li>An integer which tells us how many samples to take in each direction</li>
</ol>
</td>
</tr>
<tr>
<td>2...3</td>
<td>The <i>fDomain()</i> argument has four doubles, arranged like this:
(0)   Minimum x-value
(1)   Maximum x-value
(2)   Minimum y-value
(3)   Maximum y-value
We can access those easily enough, but since the step size in x and y direction involves so much math, it's better to cache those values, so we don't repeat the same calculation over and over again.
</td>
</tr>
<tr>
<td>5</td>
<td>Begin at the lower end of the x-domain and step through the entire domain until the maximum value has been reached. We can refer to this loop as the row-loop.</td>
</tr>
<tr>
<td>6</td>
<td>Begin at the lower end of the y-domain and step through the entire domain until the maximum value has been reached. We can refer to this loop as the column-loop.</td>
</tr>
<tr>
<td>8</td>
<td>This is where we're calling an -as of yet- non-existent function. However, I think the signature is straightforward enough to not require further explanation now.</td>
</tr>
<tr>
<td>11...13</td>
<td>Append the new vertex to the <i>V</i> list. Note that vertices are stored as a one-dimensional list, which makes accessing items at a specific (<i>row, column</i>) coordinate slightly cumbersome.</td>
</tr>
</tbody></table>

<p><img src="./8 Geometry with Python_files/primer-meshfacelogic.svg" alt="/images/primer-meshfacelogic.svg" class="float-img-right" width="325"></p>

<p>Once we have our vertices, we can create the face list that connects them. Since the face-list is topology, it doesn’t matter where our vertices are in space, all that matters is how they are organized. The image on the right is the mesh schematic that I always draw whenever confronted with mesh face  logic. The image shows a mesh with twelve vertices and six quad faces, which has the same vertex sequence logic as the vertex list created by the function on the previous page. The vertex counts in x and y direction are four and three respectively (N<sub>x</sub>=4, N<sub>y</sub>=3).</p>

<p>Now, every quad face has to link the four vertices in a counter-clockwise fashion. You may have noticed already that the absolute differences between the vertex indices on the corners of every quad are identical. In the case of the lower left quad <em>{A=0; B=3; C=4; D=1}</em>. In the case of the upper right quad <em>{A=7; B=10; C=11; D=8}</em>. We can define these numbers in a simpler way, which reduces the number of variables to just one instead of four:
<em>{A=?; B=(A+N<sub>y</sub>); C=(B+1); D=(A+1)}</em>, where <em>N<sub>y</sub></em> is the number of vertices in the y-direction. Now that we know the logic of the face corner numbers, all that is left is to iterate through all the faces we need to define and calculate proper values for the <em>A</em> corner:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createmeshfaces</span><span class="hljs-params">(resolution)</span>:</span>
    nX = resolution
    nY = resolution
    f = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nX<span class="hljs-number">-1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(nY<span class="hljs-number">-1</span>):
            baseindex = i*(nY+<span class="hljs-number">1</span>)+j
            f.append( (baseindex, baseindex+<span class="hljs-number">1</span>, baseindex+nY+<span class="hljs-number">2</span>, baseindex+nY+<span class="hljs-number">1</span>) )
    <span class="hljs-keyword">return</span> f
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2...3</td>
<td>Cache the {N<sub>x</sub>} and {N<sub>y</sub>} values, they are the same in our case because we do not allow different resolutions in {x} and {y} direction.
</td>
</tr>
<tr>
<td>4</td>
<td>Declare a list to store the faces we will create.
</td>
</tr>
<tr>
<td>5...6</td>
<td>These two nested loops are used to iterate over the grid and define a face for each row/column combo. I.e. the two values <i>i</i> and <i>j</i> are used to define the value of the A corner for each face.</td>
</tr>
<tr>
<td>7</td>
<td>Instead of the nondescript "A", we're using the variable name baseIndex. This value depends on the values of both <i>i</i> and <i>j</i>. The <i>i</i> value determines the index of the current column and the <i>j</i> value indicates the current offset (the row index).</td>
</tr>
<tr>
<td>8</td>
<td>Define the new quad face corners using the logic stated above.</td>
</tr>
</tbody></table>

<p>Writing a tool which works usually isn’t enough when you write it for other people. Apart from just working, a script should also be straightforward to use. It shouldn’t allow you to enter values that will cause it to crash (come to think of it, it shouldn’t crash at all), it should not take an eternity to complete and it should provide sensible defaults. In the case of this script, the user will have to enter a function which is potentially very complex, and also four values to define the numeric domain in {x} and {y} directions. This is quite a lot of input and chances are that only minor adjustments will be made during successive runs of the script. It therefore makes a lot of sense to remember the last used settings, so they become the defaults the next time around. There’s a number of ways of storing persistent data when using scripts, each with its own advantages:</p>

<p><img src="./8 Geometry with Python_files/primer-settings.svg" class="img-center" width="100%"></p>

<p>We’ll be using a *.txt file to store our data since it involves very little code and it survives a Rhino restart. An *.txt file is a textfile which stores a number of Strings in a one-level hierarchical format.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SaveFunctionData</span><span class="hljs-params">(strFunction, fDomain, Resolution)</span>:</span>
    file = open(<span class="hljs-string">"MeshSettings_XY.txt"</span>, <span class="hljs-string">"w"</span>)
    file.write(strFunction)
    file.write(<span class="hljs-string">"\n"</span>)
    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> fDomain:
        file.write(str(d))
        file.write(<span class="hljs-string">"\n"</span>)
    file.write(str(Resolution))
    file.close()
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2</td>
<td>This is a specialized function written specifically for this script. The signature consists only of the data it has to store. The open keyword creates a stream to the file we will be modifying. Specifying a file name without a path saves the file to the directory where the script resides. The second parameter indicates what the stream will be doing - writing in this instance.
</td>
</tr>
<tr>
<td>3...8</td>
<td>Write all settings successively to the file. We will be writing them in a specific order <i>- strFunction, fDomain</i> values 0 through 3, and the <i>Resolution</i>. The same order will be used to recover them later.
</td>
</tr>
<tr>
<td>9</td>
<td>This call finalizes modifications to the file, and closes it for other operations.</td>
</tr>
</tbody></table>

<p>The contents of the *.txt file should look something like this:</p>

<p><img src="./8 Geometry with Python_files/primer-inifile.svg" class="img-center" width="90%"></p>

<p>Reading data from an *.txt file is slightly more involved, because there is no guarantee the file exists yet. Indeed, the first time you run this script there won’t be a settings file yet and we need to make sure we supply sensible defaults:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadfunctiondata</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">try</span>:
        file = open(<span class="hljs-string">"MeshSettings_XY.txt"</span>, <span class="hljs-string">"r"</span>)
        items = file.readlines()
        file.close()
        function = str(items[<span class="hljs-number">0</span>])
        domain = (float(items[<span class="hljs-number">1</span>]), float(items[<span class="hljs-number">2</span>]),
            float(items[<span class="hljs-number">3</span>]), float(items[<span class="hljs-number">4</span>]))
        resolution = int(items[<span class="hljs-number">5</span>])
    <span class="hljs-keyword">except</span>:
        function = <span class="hljs-string">"math.cos(math.sqrt(x**2+y**2))"</span>
        domain = (<span class="hljs-number">-10.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">-10.0</span>, <span class="hljs-number">10.0</span>)
        resolution = <span class="hljs-number">50</span>
    <span class="hljs-keyword">return</span> function, domain, resolution
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2 10</td>
<td>This function needs to handle two possible conditions, the first being the first time it is called, and the second being all successive calls. The first time, there will be no <i>"MeshSettings_XY.txt"</i> file, so we will need to return default values, and create one later. This statement attempts to access the <i>"MeshSettings_XY.txt"</i> file in lines 3 to 5, and upon failure, moves to lines 11 to 13, in order to
</td>
</tr>
<tr>
<td>3</td>
<td>Obviously we need the exact same file name. If the file does not exist, the script will throw an exception. Not to worry, though. The <i>try...except</i> statement we implemented earlier will handle it, and return our default values.
</td>
</tr>
<tr>
<td>4</td>
<td>This is where we read the data strings from the \*.txt file.</td>
</tr>
<tr>
<td>6...9</td>
<td>The items recovered from the \*.txt file are distributed to their respective variables in the order that they were written to the file.</td>
</tr>
<tr>
<td>11...13</td>
<td>If an exception was thrown, we will need to return a set of default values. These are defined here.</td>
</tr>
</tbody></table>

<p><img src="./8 Geometry with Python_files/primer-xyphidelta.svg" alt="/images/primer-xyphidelta.svg" class="float-img-right" width="325"></p>

<p>We’ve now dealt with two out of four problems (mesh topology, saving and loading persistent settings) and it’s time for the big ones. In our CreateMeshVertices() procedure we’ve placed a call to a function called SolveEquation() eventhough it didn’t exist yet. SolveEquation() has to evaluate a user-defined function for a specific {x,y} coordinate which is something we haven’t done before yet. It is very easy to find the answer to the question:</p>

<p>“What is the value of <i>{Sin(x) + Sin(y)}</i> for <i>{x=0.5}</i> and <i>{y=2.7}</i> ?”</p>

<p>However, this involves manually writing the equation inside the script and then running it. Our script has to evaluate custom equations which are not known until after the script starts. This means in turn that the equation is stored as a String variable.</p>

<p>The <em>eval</em> statement runs a script inside a script. The <em>eval</em> statement takes a single String and attempts to run it as a bit of code, but nested inside the current scope. That means that you can refer to local variables inside an <em>eval</em>. This bit of magic is exactly what we need in order to evaluate expressions stored in Strings. We only need to make sure we set up our <em>x, y, Θ</em> and <em>Δ</em> variables prior to using <em>eval</em>.</p>

<p>The fourth big problem we need to solve has to do with nonsensical users (a certain school of thought popular among programmers claims that <em>all</em> users should be assumed to be nonsensical). It is possible that the custom function is not valid Python syntax, in which case the <em>eval</em> statement will not be able to parse it. This could be because of incomplete brackets, or because of typos in functions or a million other problems. But even if the function is syntactically correct it might still crash because of incorrect mathematics.</p>

<p>For example, if you try to calculate the value of <em>Sqr(-4.0)</em>, the script crashes with the “Invalid procedure call or argument” error message. The same applies to <em>Log(-4.0)</em>. These functions crash because there exists no answer for the requested value. Other types of mathematical problems arise with large numbers. <em>Exp(1000)</em> for example results in an “Overflow” error because the result falls outside the double range. Another favorite is the “Division by zero” error. The following table lists the most common errors that occur in the Python engine:</p>

<p><img src="./8 Geometry with Python_files/primer-errorchart.svg" class="img-center" width="100%"></p>

<p>See <a href="http://docs.python.org/release/3.1.3/library/exceptions.html#bltin-exceptions">Python’s list of Built-In Exceptions</a> for the complete list and descriptions of each.</p>

<p>As you can see there’s quite a lot that can go wrong. We should be able to prevent this script from crashing, even though we do not control the entire process. We could of course try to make sure that the user input is valid and will not cause any computational problems, but it is much easier to just let the script fail and recover from a crash after it happened. We’ve used the error catching mechanism previously, but back then we were just lazy, now there is no other solution.</p>

<p>The try/except statement can be used in Python as a great technique for error handling. First, the user implements a statement to “Try,” if this works then the statement is executed and we are finished. Otherwise, if an exception occurs we go straight to the “except” portion. If the error matches the exception named, the portion of code within the “except” segment is executed and we continue on. If an error happens that does not match the named “exception” then an “unhandled exception” message is thrown. Note - a try statement may have many except clauses and any given except clause may have multiple exceptions it is testing for!</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveequation</span><span class="hljs-params">( function, x, y )</span>:</span>
    d = <span class="hljs-number">10</span>
    angledata = rs.Angle( (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), (x,y,<span class="hljs-number">0</span>))
    a = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">if</span> angledata: a = angledata[<span class="hljs-number">0</span>] * math.pi/<span class="hljs-number">180</span>
    <span class="hljs-keyword">try</span>:
        z = eval(function)
    <span class="hljs-keyword">except</span>:
        z = <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> z
</code></pre>
<p>The amount of stuff the above bit of magic does is really quite impressive. It converts the {x; y} coordinates into polar coordinates {A; D} (for Angle and Distance), makes sure the angle is an actual value, in case both {x} and {y} turn out to be zero. It solves the equation to find the z-coordinate, and sets {z} to zero in case a the equation was unsolvable. Now that all the hard work is done, all that is left is to write the over arching function that provides the interface for this script, which I don’t think needs further explanation:</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">meshfunction_xy</span><span class="hljs-params">()</span>:</span>
    zfunc, domain, resolution = loadfunctiondata()
    zfunc = rs.StringBox( zfunc, <span class="hljs-string">"Specify a function f(x,y[,D,A])"</span>, <span class="hljs-string">"Mesh function"</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> zfunc: <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        prompt = <span class="hljs-string">"Function domain x{domain[0],domain[1]} y{domain[2],domain[3]} @resolution"</span>
        result = rs.GetString(prompt, <span class="hljs-string">"Insert"</span>, (<span class="hljs-string">"xMin"</span>,<span class="hljs-string">"xMax"</span>,<span class="hljs-string">"yMin"</span>,<span class="hljs-string">"yMax"</span>, <span class="hljs-string">"Resolution"</span>,<span class="hljs-string">"Insert"</span>))
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result: <span class="hljs-keyword">return</span>
        result = result.upper()
        <span class="hljs-keyword">if</span> result==<span class="hljs-string">"XMIN"</span>:
            f = rs.GetReal(<span class="hljs-string">"X-Domain start"</span>, domain[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: domain[<span class="hljs-number">0</span>]=f
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"XMAX"</span>:
            f = rs.GetReal(<span class="hljs-string">"X-Domain end"</span>, domain[<span class="hljs-number">1</span>])
            <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: domain[<span class="hljs-number">1</span>]=f
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"YMIN"</span>:
            f = rs.GetReal(<span class="hljs-string">"Y-Domain start"</span>, domain[<span class="hljs-number">2</span>])
            <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: domain[<span class="hljs-number">2</span>]=f
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"YMAX"</span>:
            f = rs.GetReal(<span class="hljs-string">"Y-Domain end"</span>, domain[<span class="hljs-number">3</span>])
            <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: domain[<span class="hljs-number">3</span>]=f
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"RESOLUTION"</span>:
            f = rs.GetInteger(<span class="hljs-string">"Resolution of the graph"</span>, resolution)
            <span class="hljs-keyword">if</span> f <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>: resolution=f
        <span class="hljs-keyword">elif</span> result==<span class="hljs-string">"INSERT"</span>: <span class="hljs-keyword">break</span>

    verts = createmeshvertices(zfunc, domain, resolution)
    faces = createmeshfaces(resolution)
    rs.AddMesh(verts, faces)
    SaveFunctionData(zfunc, domain, resolution)
</code></pre>

<p>The default function Cos(Sqr(x^2 + y^2)) is already quite pretty, but here are some other functions to play with as well:</p>

<table width="100%" class="multiline-middle">
<tbody><tr>
<th>Notation</th>
<th width="30%">Syntax</th>
<th>result</th>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-17-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;cos&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msqrt&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/msqrt&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-205" style="width: 8.199em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.714em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.898em, 1006.51em, 4.101em, -999.997em); top: -3.276em; left: 0em;"><span class="mrow" id="MathJax-Span-206"><span class="mi" id="MathJax-Span-207" style="font-family: MathJax_Main;">cos</span><span class="mo" id="MathJax-Span-208"></span><span class="mrow" id="MathJax-Span-209"><span class="mo" id="MathJax-Span-210" style="vertical-align: 0em;"><span style="font-family: MathJax_Size2;">(</span></span><span class="msqrt" id="MathJax-Span-211"><span style="display: inline-block; position: relative; width: 4.203em; height: 0px;"><span style="position: absolute; clip: rect(2.974em, 1003.18em, 4.357em, -999.997em); top: -3.993em; left: 1.027em;"><span class="mrow" id="MathJax-Span-212"><span class="msubsup" id="MathJax-Span-213"><span style="display: inline-block; position: relative; width: 1.027em; height: 0px;"><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-214" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.566em;"><span class="mn" id="MathJax-Span-215" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-216" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="msubsup" id="MathJax-Span-217" style="padding-left: 0.207em;"><span style="display: inline-block; position: relative; width: 0.976em; height: 0px;"><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.357em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-218" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.566em;"><span class="mn" id="MathJax-Span-219" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.589em, 1003.18em, 3.947em, -999.997em); top: -4.915em; left: 1.027em;"><span style="display: inline-block; position: relative; width: 3.179em; height: 0px;"><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: -0.1em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: 2.513em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 0.412em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 0.925em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 1.437em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 2.001em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(2.718em, 1001.03em, 4.818em, -999.997em); top: -4.045em; left: 0em;"><span style="font-family: MathJax_Size2;">√</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-220" style="vertical-align: 0em;"><span style="font-family: MathJax_Size2;">)</span></span></span></span><span style="display: inline-block; width: 0px; height: 3.281em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>cos</mi><mo>⁡</mo><mrow><mo>(</mo><msqrt><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></msqrt><mo>)</mo></mrow></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-17">\cos\left(\sqrt{x^2 + y^2}\right)</script></td>
<td>math.cos(math.sqrt(x*x + y*y))</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-b.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-18-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-221" style="width: 7.636em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.253em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.283em, 1006.15em, 2.615em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-222"><span class="mi" id="MathJax-Span-223" style="font-family: MathJax_Main;">sin</span><span class="mo" id="MathJax-Span-224"></span><span class="mo" id="MathJax-Span-225" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-226" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-227" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-228" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-229" style="font-family: MathJax_Main; padding-left: 0.207em;">sin</span><span class="mo" id="MathJax-Span-230"></span><span class="mo" id="MathJax-Span-231" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-232" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-233" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-18">\sin(x) + \sin(y)</script></td>
<td>math.sin(x) + math.sin(y)</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-a.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-19-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-234" style="width: 5.843em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.767em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.283em, 1004.66em, 2.615em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-235"><span class="mi" id="MathJax-Span-236" style="font-family: MathJax_Main;">sin</span><span class="mo" id="MathJax-Span-237"></span><span class="mo" id="MathJax-Span-238" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-239" style="font-family: MathJax_Math-italic;">D</span><span class="mo" id="MathJax-Span-240" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-241" style="font-family: MathJax_Math-italic; padding-left: 0.207em;">A</span><span class="mo" id="MathJax-Span-242" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>D</mi><mo>+</mo><mi>A</mi><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-19">\sin(D + A)</script></td>
<td>math.sin(D+A)</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-l.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-20-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msqrt&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/msqrt&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-243" style="width: 8.916em; display: inline-block;"><span style="display: inline-block; position: relative; width: 7.277em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.898em, 1007.07em, 4.101em, -999.997em); top: -3.276em; left: 0em;"><span class="mrow" id="MathJax-Span-244"><span class="mi" id="MathJax-Span-245" style="font-family: MathJax_Math-italic;">A</span><span class="mi" id="MathJax-Span-246" style="font-family: MathJax_Math-italic;">t</span><span class="mi" id="MathJax-Span-247" style="font-family: MathJax_Math-italic;">n</span><span class="mrow" id="MathJax-Span-248" style="padding-left: 0.156em;"><span class="mo" id="MathJax-Span-249" style="vertical-align: 0em;"><span style="font-family: MathJax_Size2;">(</span></span><span class="msqrt" id="MathJax-Span-250"><span style="display: inline-block; position: relative; width: 4.203em; height: 0px;"><span style="position: absolute; clip: rect(2.974em, 1003.18em, 4.357em, -999.997em); top: -3.993em; left: 1.027em;"><span class="mrow" id="MathJax-Span-251"><span class="msubsup" id="MathJax-Span-252"><span style="display: inline-block; position: relative; width: 1.027em; height: 0px;"><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-253" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.566em;"><span class="mn" id="MathJax-Span-254" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-255" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="msubsup" id="MathJax-Span-256" style="padding-left: 0.207em;"><span style="display: inline-block; position: relative; width: 0.976em; height: 0px;"><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.357em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-257" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.566em;"><span class="mn" id="MathJax-Span-258" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.589em, 1003.18em, 3.947em, -999.997em); top: -4.915em; left: 1.027em;"><span style="display: inline-block; position: relative; width: 3.179em; height: 0px;"><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: -0.1em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: 2.513em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 0.412em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 0.925em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 1.437em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 2.001em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(2.718em, 1001.03em, 4.818em, -999.997em); top: -4.045em; left: 0em;"><span style="font-family: MathJax_Size2;">√</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-259" style="vertical-align: 0em;"><span style="font-family: MathJax_Size2;">)</span></span></span></span><span style="display: inline-block; width: 0px; height: 3.281em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>A</mi><mi>t</mi><mi>n</mi><mrow><mo>(</mo><msqrt><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></msqrt><mo>)</mo></mrow></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-20">Atn\left(\sqrt{x^2 + y^2}\right)</script></td>
<td>math.atan(x*x + y*y)<br>-or-<br>math.atan(D)</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-d.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-21-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;msqrt&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;|&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;|&lt;/mo&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-260" style="width: 8.251em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.765em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(0.925em, 1006.76em, 3.025em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-261"><span class="msqrt" id="MathJax-Span-262"><span style="display: inline-block; position: relative; width: 2.257em; height: 0px;"><span style="position: absolute; clip: rect(3.076em, 1001.03em, 4.408em, -999.997em); top: -3.993em; left: 1.027em;"><span class="mrow" id="MathJax-Span-263"><span class="texatom" id="MathJax-Span-264"><span class="mrow" id="MathJax-Span-265"><span class="mo" id="MathJax-Span-266" style="font-family: MathJax_Main;">|</span></span></span><span class="mi" id="MathJax-Span-267" style="font-family: MathJax_Math-italic;">x</span><span class="texatom" id="MathJax-Span-268"><span class="mrow" id="MathJax-Span-269"><span class="mo" id="MathJax-Span-270" style="font-family: MathJax_Main;">|</span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.589em, 1001.23em, 3.947em, -999.997em); top: -4.813em; left: 1.027em;"><span style="display: inline-block; position: relative; width: 1.232em; height: 0px;"><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: -0.1em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: 0.566em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(2.718em, 1001.03em, 4.818em, -999.997em); top: -3.993em; left: 0em;"><span style="font-family: MathJax_Size2;">√</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-271" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-272" style="font-family: MathJax_Main; padding-left: 0.207em;">sin</span><span class="mo" id="MathJax-Span-273"></span><span class="mo" id="MathJax-Span-274" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-275" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="msubsup" id="MathJax-Span-276"><span style="display: inline-block; position: relative; width: 1.181em; height: 0px;"><span style="position: absolute; clip: rect(3.076em, 1000.31em, 4.408em, -999.997em); top: -3.993em; left: 0em;"><span class="mo" id="MathJax-Span-277" style="font-family: MathJax_Main;">)</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.412em;"><span class="texatom" id="MathJax-Span-278"><span class="mrow" id="MathJax-Span-279"><span class="mn" id="MathJax-Span-280" style="font-size: 70.7%; font-family: MathJax_Main;">16</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.316em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msqrt><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></msqrt><mo>+</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mn>16</mn></mrow></msup></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-21">\sqrt{|x|} + \sin(y)^{16}</script></td>
<td>math.sqrt(math.fabs(x))+math.pow(math.sin(y),16)</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-e.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-22-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msqrt&gt;&lt;mo movablelimits=&quot;true&quot; form=&quot;prefix&quot;&gt;min&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/msqrt&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-281" style="width: 10.146em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.302em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.949em, 1008.1em, 4.101em, -999.997em); top: -3.276em; left: 0em;"><span class="mrow" id="MathJax-Span-282"><span class="mi" id="MathJax-Span-283" style="font-family: MathJax_Main;">sin</span><span class="mo" id="MathJax-Span-284"></span><span class="mrow" id="MathJax-Span-285"><span class="mo" id="MathJax-Span-286" style="vertical-align: 0em;"><span style="font-family: MathJax_Size2;">(</span></span><span class="msqrt" id="MathJax-Span-287"><span style="display: inline-block; position: relative; width: 5.894em; height: 0px;"><span style="position: absolute; clip: rect(2.974em, 1004.77em, 4.408em, -999.997em); top: -3.993em; left: 1.027em;"><span class="mrow" id="MathJax-Span-288"><span class="mo" id="MathJax-Span-289" style="font-family: MathJax_Main;">min</span><span class="mo" id="MathJax-Span-290" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-291"><span style="display: inline-block; position: relative; width: 1.027em; height: 0px;"><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-292" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.566em;"><span class="mn" id="MathJax-Span-293" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-294" style="font-family: MathJax_Main;">,</span><span class="msubsup" id="MathJax-Span-295" style="padding-left: 0.156em;"><span style="display: inline-block; position: relative; width: 0.976em; height: 0px;"><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.357em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-296" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -4.403em; left: 0.566em;"><span class="mn" id="MathJax-Span-297" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-298" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.589em, 1004.87em, 3.947em, -999.997em); top: -4.864em; left: 1.027em;"><span style="display: inline-block; position: relative; width: 4.869em; height: 0px;"><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: -0.1em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; font-family: MathJax_Main; top: -3.993em; left: 4.203em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 0.412em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 0.976em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 1.488em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 2.052em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 2.564em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 3.128em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="font-family: MathJax_Main; position: absolute; top: -3.993em; left: 3.64em;">−<span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(2.718em, 1001.03em, 4.818em, -999.997em); top: -4.045em; left: 0em;"><span style="font-family: MathJax_Size2;">√</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-299" style="vertical-align: 0em;"><span style="font-family: MathJax_Size2;">)</span></span></span></span><span style="display: inline-block; width: 0px; height: 3.281em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>sin</mi><mo>⁡</mo><mrow><mo>(</mo><msqrt><mo movablelimits="true" form="prefix">min</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msup><mi>y</mi><mn>2</mn></msup><mo stretchy="false">)</mo></msqrt><mo>)</mo></mrow></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-22">\sin\left(\sqrt{\min(x^2, y^2)}\right)</script></td>
<td>math.sin(min(math.pow([x*x, y*y]),0.5))</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-f.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-23-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-300" style="width: 12.605em; display: inline-block;"><span style="display: inline-block; position: relative; width: 10.3em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.283em, 1010.2em, 2.615em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-301"><span class="mrow" id="MathJax-Span-302"><span class="mo" id="MathJax-Span-303" style="font-family: MathJax_Main;">[</span><span class="mrow" id="MathJax-Span-304"><span class="mi" id="MathJax-Span-305" style="font-family: MathJax_Main;">sin</span><span class="mo" id="MathJax-Span-306"></span><span class="mo" id="MathJax-Span-307" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-308" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-309" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-310" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-311" style="font-family: MathJax_Main; padding-left: 0.207em;">sin</span><span class="mo" id="MathJax-Span-312"></span><span class="mo" id="MathJax-Span-313" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-314" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-315" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-316" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-317" style="font-family: MathJax_Math-italic; padding-left: 0.207em;">x</span><span class="mo" id="MathJax-Span-318" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-319" style="font-family: MathJax_Math-italic; padding-left: 0.207em;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span class="mo" id="MathJax-Span-320" style="font-family: MathJax_Main;">]</span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mo>[</mo><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo>]</mo></mrow></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-23">\left[\sin(x) + \sin(y) + x + y\right]</script></td>
<td>int(math.sin(x) + math.sin(y) + x + y)</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-g.svg" width="100%"></td>
</tr>
<tr>
<td><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-24-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;log&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;sin&lt;/mi&gt;&lt;mo&gt;&amp;#x2061;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2.01&lt;/mn&gt;&lt;/mrow&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-321" style="width: 13.783em; display: inline-block;"><span style="display: inline-block; position: relative; width: 11.273em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.283em, 1011.17em, 2.615em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-322"><span class="mi" id="MathJax-Span-323" style="font-family: MathJax_Main;">log</span><span class="mo" id="MathJax-Span-324"></span><span class="mrow" id="MathJax-Span-325"><span class="mo" id="MathJax-Span-326" style="font-family: MathJax_Main;">(</span><span class="mrow" id="MathJax-Span-327"><span class="mi" id="MathJax-Span-328" style="font-family: MathJax_Main;">sin</span><span class="mo" id="MathJax-Span-329"></span><span class="mo" id="MathJax-Span-330" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-331" style="font-family: MathJax_Math-italic;">x</span><span class="mo" id="MathJax-Span-332" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-333" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mi" id="MathJax-Span-334" style="font-family: MathJax_Main; padding-left: 0.207em;">sin</span><span class="mo" id="MathJax-Span-335"></span><span class="mo" id="MathJax-Span-336" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-337" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-338" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-339" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="mn" id="MathJax-Span-340" style="font-family: MathJax_Main; padding-left: 0.207em;">2.01</span></span><span class="mo" id="MathJax-Span-341" style="font-family: MathJax_Main;">)</span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.378em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2.01</mn></mrow><mo>)</mo></mrow></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-24">\log\left(\sin(x) + \sin(y) + 2.01\right)</script></td>
<td>math.log(math.sin(x)+math.sin(y)+2.01)</td>
<td><img src="./8 Geometry with Python_files/primer-meshxy-h.svg" width="100%"></td>
</tr>
</tbody></table>

<h3 id="882-shape-vs-image">8.8.2 Shape vs. Image</h3>

<p>The vertex and face lists of a mesh object define its form (geometry and topology) but meshes can also have local display attributes. Colors and Texture-coordinates are two of these that we can control via RhinoScriptSyntax.  The color list (usually referred to as ‘False-Colors’) is an optional mesh property which defines individual colors for every vertex in the mesh. The only Rhino commands that I know of that generate meshes with false-color data are the analysis commands <em>(_DraftAngleAnalysis, _ThicknessAnalysis, _CurvatureAnalysis and so on and so forth)</em> but unfortunately they do not allow you to export the analysis meshes. Before we do something useful with False-Color meshes, let’s do something simple, like assigning random colours to a mesh object:</p>

<p><img src="./8 Geometry with Python_files/primer-meshfalsecolours.svg" class="img-center" width="80%"></p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randommeshcolors</span><span class="hljs-params">()</span>:</span>
    mesh_id = rs.GetObject(<span class="hljs-string">"Mesh to randomize"</span>, <span class="hljs-number">32</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mesh_id: <span class="hljs-keyword">return</span>

    verts = rs.MeshVertices(mesh_id)
    faces = rs.MeshFaceVertices(mesh_id)
    colors = []
    <span class="hljs-keyword">for</span> vert <span class="hljs-keyword">in</span> verts:
        rgb = random()*<span class="hljs-number">255</span>, random()*<span class="hljs-number">255</span>, random()*<span class="hljs-number">255</span>
        colors.append(rgb)
    rs.AddMesh(verts, faces, vertex_colors=colors)
    rs.DeleteObject(mesh_id)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>7...11</td>
<td>The False-Color array is optional, but there are rules to using it. If we decide to specify a False-Color array, we have to make sure that it has the exact same number of elements as the vertex array. After all, every vertex needs its own colour. We must also make sure that every element in the False-Color array represents a valid colour. Colours in Rhino are defined as integers which store the red, green and blue channels. The channels are defined as numbers in the range {0; 255}, and they are mashed together into a bigger number where each channel is assigned its own niche. The advantage of this is that all colours are just numbers instead of more complex data-types, but the downside is that these numbers are usually meaningless for mere mortals:<br><br>


<img src="./8 Geometry with Python_files/primer-colortable.svg" width="60%" float="right"><br>

<sup>1</sup> Lowest possible value<br>
<sup>2</sup> Highest possible value
</td>
</tr>
</tbody></table>

<p>Random colors may be pretty, but they are not useful. All the Rhino analysis commands evaluate a certain geometrical local property (curvature, verticality, intersection distance, etc), but none of them take surroundings into account. Let’s assume we need a tool that checks a mesh and a (poly)surface for proximity. There is nothing in Rhino that can do that out of the box. So this is actually going to be a useful script, plus we’ll make sure that the script is completely modular so we can easily adjust it to analyze other properties.</p>

<p>We’ll need a function who’s purpose it is to generate an array of numbers (one for each vertex in a mesh) that define some kind of property. These numbers are then in turn translated into a gradient (red for the lowest number, white for the highest number in the set) and applied as the False-Color data to a new mesh object. In our case the property is the distance from a certain vertex to the point on a (poly)surface which is closest to that vertex:</p>

<p><img src="./8 Geometry with Python_files/primer-boxcp.svg" class="img-center" width="80%"></p>

<p><img src="./8 Geometry with Python_files/primer-loggraph.svg" alt="/images/primer-loggraph.svg" class="float-img-right" width="300"></p>

<p>Vertex {A} on the mesh has a point associated with it {Acp} on the box and the distance between these two {DA} is a measure for proximity. This measure is linear, which means that a vertex which is twice as far away gets a proximity value which is twice as high. A linear distribution is indicated by the red line in the adjacent graph. It actually makes more intuitive sense to use a logarithmic scale (the green line), since it is far better at dealing with huge value ranges. Imagine we have a mesh whose sorted proximity value set is something like:</p>

<p>{0.0; 0.0; 0.0; 0.1; 0.2; 0.5; 1.1; 1.8; 2.6; … ; 9.4; 1000.0}</p>

<p>As you can see pretty much all the variation is within the {0.0; 10.0} range, with just a single value radically larger. Now, if we used a linear approach, all the proximity values would resolve to completely red, except for the last one which would resolve to completely white. This is not a useful gradient. When you run all the proximity values through a logarithm you end up with a much more natural distribution:</p>

<p><img src="./8 Geometry with Python_files/primer-gradienttable.svg" class="img-center" width="100%"></p>

<p>There is just one snag, the logarithm function returns negative numbers for input between zero and one. In fact, the logarithm of zero is minus-infinity, which plays havoc with all mathematics down the road since infinity is way beyond the range of numbers we can represent using doubles. And since the smallest possible distance between two points in space is zero, we cannot just apply a logarithm and expect our script to work. The solution is a simple one, add 1.0 to all distance values prior to calculating the logarithm, and all our results are nice, positive numbers.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VertexValueArray</span><span class="hljs-params">(points, id)</span>:</span>
    <span class="hljs-keyword">return</span> [DistanceTo(point, id) <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points]

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DistanceTo</span><span class="hljs-params">(pt, id)</span>:</span>
    ptCP = rs.BrepClosestPoint(id,pt)
    <span class="hljs-keyword">if</span> ptCP:
        d = rs.Distance(pt, ptCP[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">return</span> math.log10(d+<span class="hljs-number">1</span>)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1...2</td>
<td>The <i>VertexValueArray()</i> function is the one that creates a list of numbers for each vertex. We're giving it the mesh vertices (an array of 3D points) and the object ID of the (poly)surface for the proximity analysis. This function doesn't do much, it simply iterates through the list of points using the <i>DistanceTo()</i> function, and returns a list of the results.
</td>
</tr>
<tr>
<td>4...8</td>
<td><i>DistanceTo()</i> calculates the distance from pt to the projection of pt onto id. Where pt is a single 3D coordinate and id if the identifier of a (poly)surface object. It also performs the logarithmic conversion, so the return value is not the actual distance.
</td>
</tr>
</tbody></table>

<p>And the master Sub containing all the front end and color magic:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</code><code class="language-python hljs"><span class="hljs-keyword">import</span> rhinoscriptsyntax <span class="hljs-keyword">as</span> rs
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> math

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ProximityAnalysis</span><span class="hljs-params">()</span>:</span>
    mesh_id = rs.GetObject(<span class="hljs-string">"Mesh for proximity analysis"</span>, <span class="hljs-number">32</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> mesh_id: <span class="hljs-keyword">return</span>

    brep_id = rs.GetObject(<span class="hljs-string">"Surface for proximity test"</span>, <span class="hljs-number">8</span>+<span class="hljs-number">16</span>, <span class="hljs-keyword">False</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> brep_id: <span class="hljs-keyword">return</span>

    vertices = rs.MeshVertices(mesh_id)
    faces = rs.MeshFaceVertices(mesh_id)
    listD = VertexValueArray(vertices, brep_id)

    minD = sys.float_info.min
    maxD = sys.float_info.max
    <span class="hljs-keyword">for</span> ct <span class="hljs-keyword">in</span> range(len(listD)):
        <span class="hljs-keyword">if</span> minD&gt;listD[ct]: minD = listD[ct]
        <span class="hljs-keyword">if</span> maxD&lt;listD[ct]: maxD = listD[ct]

    colors = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(vertices)):
        proxFactor = (listD[i]-minD)/(maxD-minD)
        colors.append((<span class="hljs-number">255</span>, <span class="hljs-number">255</span>*proxFactor, <span class="hljs-number">255</span>*proxFactor))
    rs.AddMesh(vertices, faces, vertex_colors=colors)
    rs.DeleteObject(mesh_id)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1...3</td>
<td>There are a couple of import statements that may look unfamiliar here. In some scripts, the use of outside resources can come in handy. Importing the System namespace allows us to use objects from the .Net framework, such as the maximum and minimum values of all floating point variables.
</td>
</tr>
<tr>
<td>16...20</td>
<td>Since there is not a function in the math namespace, .net, or the rhinoscriptsyntax methods to get the max and min values of an array of numbers, we will have to write some code to get the maximum and minimum values of <i>listD</i>. The .Net framework is a wonderful place, and for the first time, IronPython allows its use in scripts within Rhinoceros. We call the System namespace, and get the max and min values of all double-precision numbers, as a starting point. We then iterate through the items in <i>listD</i>, comparing each value to the current value of <i>maxD</i> and <i>minD</i>, replacing them if we happen to find a more suitable member of the list for either. Once we have iterated through the entire list, we are certain we have the max and min values.
</td>
</tr>
<tr>
<td>22</td>
<td>Create the False-Color array..</td>
</tr>
<tr>
<td>24</td>
<td>Calculate the position on the {Red~White} gradient for the current value.</td>
</tr>
<tr>
<td>25</td>
<td>Cook up a colour based on the <i>proxFactor</i>.</td>
</tr>
</tbody></table>

<h2 id="89-surfaces">8.9 Surfaces</h2>

<p>At this point you should have a fair idea about the strengths and flexibility of mesh based surfaces. It is no surprise that many industries have made meshes their primary means of surfacing. However, meshes also have their disadvantages and this is where other surfacing paradigms come into play.</p>

<p>In fact, meshes (like nurbs) are a fairly recent discovery whose rise to power depended heavily on demand from the computer industry. Mathematicians have been dealing with different kinds of surface definitions for centuries and they have come up with a lot of them; surfaces defined by explicit functions, surfaces defined by implicit equations, minimal area surfaces, surfaces of revolutions, fractal surfaces and many more. Most of these types are far too abstract for your every-day modeling job, which is why most CAD packages do not implement them.</p>

<figure>
    <img src="./8 Geometry with Python_files/primer-schwarz-d-surface.jpg" width="60%" float="right">
    <figcaption width="60%">Schwarz D surface, a triply periodic minimal surface which divides all of space between here and the edge of creation into two equal chunks. Easy to define mathematically, hard to model manually.</figcaption>
</figure>
<p><br><br>
Apart from a few primitive surface types such as spheres, cones, planes and cylinders, Rhino supports three kinds of freeform surface types, the most useful of which is the Nurbs surface. Similar to curves, all possible surface shapes can be represented by a Nurbs surface, and this is the default fall-back in Rhino. It is also by far the most useful surface definition and the one we will be focusing on.</p>

<p><img src="./8 Geometry with Python_files/primer-primitives.svg" class="img-center" width="100%"></p>

<h3 id="891-nurbs-surfaces">8.9.1 NURBS Surfaces</h3>

<p><img src="./8 Geometry with Python_files/primer-normals.svg" alt="/images/primer-normals.svg" class="float-img-right" width="325"></p>

<p>Nurbs surfaces are very similar to Nurbs curves. The same algorithms are used to calculate shape, normals, tangents, curvatures and other properties, but there are some distinct differences. For example, curves have tangent vectors and normal planes, whereas surfaces have normal vectors and tangent planes. This means that curves lack orientation while surfaces lack direction. This is of course true for all curve and surface types and it is something you’ll have to learn to live with. Often when writing code that involves curves or surfaces you’ll have to make assumptions about direction and orientation and these assumptions will sometimes be wrong.</p>

<p>In the case of NURBS surfaces there are in fact two directions implied by the geometry, because NURBS surfaces are rectangular grids of {u} and {v} curves. And even though these directions are often arbitrary, we end up using them anyway because they make life so much easier for us.</p>

<p>But lets start with something simple which doesn’t actually involve NURBS surface mathematics on our end. The problem we’re about to be confronted with is called Surface Fitting and the solution is called Error Diffusion. You have almost certainly come across this term in the past, but probably not in the context of surface geometry. Typically the words “error diffusion” are only used in close proximity to the words “color”, “pixel” and “dither”, but the wide application in image processing doesn’t limit error diffusion algorithms to the 2D realm.</p>

<p>The problem we’re facing is a mismatch between a given surface and a number of points that are supposed to be on it. We’re going to have to change the surface so that the distance between it and the points is minimized. Since we should be able to supply a large amount of points (and since the number of surface control-points is limited and fixed) we’ll have to figure out a way of deforming the surface in a non-linear fashion (i.e. translations and rotations alone will not get us there). Take a look at the images below which are a schematic representation of the problem:</p>

<p><img src="./8 Geometry with Python_files/primer-pointonplane.svg" class="img-center" width="100%"></p>

<p>For purposes of clarity I have unfolded a very twisted nurbs patch so that it is reduced to a rectangular grid of control-points. The diagram you’re looking at is drawn in {uvw} space rather than world {xyz} space. The actual surface might be contorted in any number of ways, but we’re only interested in the simplified {uvw} space.</p>

<p>The surface has to pass through point {S}, but currently the two entities are not intersecting. The projection of {S} onto the surface {S’} is a certain distance away from {S} and this distance is the error we’re going to diffuse. As you can see, {S’} is closer to some control points than others. Especially {F} and {G} are close, but
{B; C; J; K} can also be considered adjacent control points. Rather than picking a fixed number of nearby control points and moving those in order to reduce the distance between {S} and {S’}, we’re going to move all the points, but not in equal amounts. The images on the right show the amount of motion we assign to each control point based on its distance to {S’}.
You may have noticed a problem with the algorithm description so far. If a nurbs surface is flat, the control-points lie on the surface itself, but when the surface starts to buckle and bend, the control points have a tendency to move away from the surface. This means that the distance between the control points {uvw} coordinate and {S’} is less meaningful. So instead of control points, we’ll be using Greville points. Both nurbs curves and nurbs surfaces have a set of Greville points (or “edit points” as they are known in Rhino), but only curves expose this in the Rhino interface. As scripters we also get access to surface Greville points, which is useful because there is a 1:1 mapping between control and Greville points and the latter are guaranteed to lie on the surface. Greville points can therefore be expressed in {uv} coordinates only, which means we can also evaluate surface properties (such as tangency, normals and curvature) at these exact locations.</p>

<p>The only thing left undecided at this point is the equation we’re going to use to determine the amount of motion we’re going to assign to a certain control point based on its distance from {S’}. It seems obvious that all the control points that are “close” should be affected much more than those which are farther away. The minimum distance between two points in space is zero (negative distance only makes sense in certain contexts, which we’ll get to shortly) and the maximum distance is infinity. This means we need a graph that goes from zero to infinity on the x-axis and which yields a lower value for {y} for every higher value of {x}. If the graph ever goes below zero it means we’re deforming the surface with a negative error. This is not a bad thing per se, but let’s keep it simple for the time being.</p>

<p>Our choices are already pretty limited by these constraints, but there are still some worthy contestants. If this were a primer about mathematics I’d probably have gone for a Gaussian distribution, but instead we’ll use an extremely simple equation known as a hyperbola. If we define the diffusion factor of a Greville point as the inverse of its distance to {S’}, we get this hyperbolic function:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-25-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mfrac&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-342" style="width: 4.972em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.05em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(0.72em, 1004.05em, 3.076em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-343"><span class="mi" id="MathJax-Span-344" style="font-family: MathJax_Math-italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span class="mo" id="MathJax-Span-345" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-346" style="font-family: MathJax_Math-italic;">y<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-347" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-348" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mfrac" id="MathJax-Span-349" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 0.72em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.179em, 1000.41em, 4.152em, -999.997em); top: -4.659em; left: 50%; margin-left: -0.254em;"><span class="mn" id="MathJax-Span-350" style="font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.384em, 1000.51em, 4.152em, -999.997em); top: -3.327em; left: 50%; margin-left: -0.305em;"><span class="mi" id="MathJax-Span-351" style="font-family: MathJax_Math-italic;">x</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1000.72em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.72em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.934em; border-left: 0px solid; width: 0px; height: 2.628em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>x</mi></mfrac></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-25">f(y)=\frac{1}{x}</script>

<p><img src="./8 Geometry with Python_files/primer-distanceweightfactor.svg" class="img-center" width="80%"></p>

<p>As you can see, the domain of the graph goes from zero to infinity, and for every higher value of {x} we get a lower value of {y}, without {y} ever becoming zero. There’s just one problem, a problem which only manifests itself in programming. For very small values of {x}, when the Greville point is very close to {S’}, the resulting {y} is very big indeed. When this distance becomes zero the weight factor becomes infinite, but we’ll never get even this far. Even though the processor in your computer is in theory capable of representing numbers as large as
1.8 × 10308 (which isn’t anywhere near infinity by any stretch of the imagination), when you start doing calculations with numbers approaching the extremes chances are you are going to cross over into binary no man’s land and crash your pc. And that’s not even to mention the deplorable mathematical accuracy at these levels of scale. Clearly, you might want to steer clear of very big and very small numbers altogether.</p>

<p>It’s an easy fix in our case, we can simply limit the {x} value to the domain {+0.01; +∞}, meaning that {y} can never get bigger than 100. We could make this threshold much, much smaller without running into problems. Even if we limit {x} to a billionth of a unit (0.00000001) we’re still comfortably in the clear.</p>

<p><img src="./8 Geometry with Python_files/primer-surface-uvw-to-xyz.svg" alt="/images/primer-surface-uvw-to-xyz.svg" class="float-img-right" width="325"></p>

<p>The first thing we need to do is write a function that takes a surface and a point in {xyz} coordinates and translates it into {uvw} coordinates. We can use the <i>rs.SurfaceClosestPoint()</i> method to get the {u} and {v} components, but the {w} is going to take some thinking.</p>

<p>First of all, a surface is a 2D entity meaning it has no thickness and thus no “real” {z} or {w} component. But a surface does have normal vectors that point away from it and which can be used to emulate a “depth” dimension. In the adjacent illustration you can see a point in {uvw} coordinates, where the value of {w} is simply the distance between the point and the start of the line. It is in this respect that negative distance has meaning, because negative distance denotes a {w} coordinate on the other side of the surface.</p>

<p>Although this is a useful way of describing coordinates in surface space, you should at all times remember that the {u} and {v} components are expressed in surface parameter space while the {w} component is expressed in world units. We are using mixed coordinate systems which means that we cannot blindly use distances or angles between these points because those properties are meaningless now.</p>

<p>In order to find the coordinates in surface {S} space of a point {P}, we need to find the projection {P’} of {P} onto {S}. Then we need to find the distance between {P} and {P’} so we know the magnitude of the {w} component and then we need to figure out on which side of the surface {P} is in order to figure out the sign of {w} (positive or negative). Since our script will be capable of fitting a surface to multiple points, we might as well make our function list-capable:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ConvertToUVW</span><span class="hljs-params">(idSrf, pXYZ)</span>:</span>
    pUVW = []
    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> pXYZ:
        u, v = rs.SurfaceClosestPoint(idSrf, point)
        surface_xyz = rs.EvaluateSurface(idSrf, u, v)
        surface_normal = rs.SurfaceNormal(idSrf, (u,v))

        dirPos = rs.PointAdd(surface_xyz, surface_normal)
        dirNeg = rs.PointSubtract(surface_xyz, surface_normal)
        dist = rs.Distance(surface_xyz, point)

        <span class="hljs-keyword">if</span> (rs.Distance(point, dirPos) &gt; rs.Distance(point, dirNeg)): dist *= <span class="hljs-number">-1</span>
        pUVW.append((u, v, dist)) 	
    <span class="hljs-keyword">return</span> pUVW
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td><i>pXYZ()</i> is an array of points expressed in world coordinates.
</td>
</tr>
<tr>
<td>4...6</td>
<td>Find the {uv} coordinate of {P'}, the {xyz} coordinates of {P'} and the surface normal vector at {P'}.
</td>
</tr>
<tr>
<td>8...10</td>
<td>Add and subtract the normal to the {xyz} coordinates of {P'} to get two points on either side of {P'}.</td>
</tr>
<tr>
<td>12...13</td>
<td>If {P} is closer to the dirNeg point, we know that {P} is on the "downside" of the surface and we need to make {w} negative.</td>
</tr>
</tbody></table>

<p>We need some other utility functions as well (it will become clear how they fit into the grand scheme of things later) so let’s get it over with quickly:</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GrevilleNormals</span><span class="hljs-params">(idSrf)</span>:</span>
  uvGreville = rs.SurfaceEditPoints(idSrf, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
  srfNormals = [rs.SurfaceNormal(idSrf, grev) <span class="hljs-keyword">for</span> grev <span class="hljs-keyword">in</span> uvGreville]

  <span class="hljs-keyword">return</span> srfNormals
</code></pre>
<p>This function takes a surface and returns a list of normal vectors for every Greville point. There’s nothing special going on here, you should be able to read this function without even consulting help files at this stage. The same goes for the next function, which takes a list of vectors and a list of numbers and divides each vector with the matching number. This function assumes that <em>Vectors</em> and <em>Factors</em> are lists of equal size.</p>

<pre><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DivideVectorList</span><span class="hljs-params">(Vectors, Factors)</span>:</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(Vectors)):
        Vectors[i] = rs.VectorDivide(Vectors[i], Factors[i])
        <span class="hljs-keyword">return</span> Vectors
</code></pre>

<p>Our eventual algorithm will keep track of both motion vectors and weight factors for each control point on the surface (for reasons I haven’t explained yet), and we need to instantiate these lists with default values. Even though that is pretty simple stuff, I decided to move the code into a separate procedure anyway in order to keep all the individual procedures small. The return value for this function are two lists: Forces and Factors.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">InstantiateForceLists</span><span class="hljs-params">(Bound)</span>:</span>
    Forces = []
    Factors = []

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(Bound):
        Forces.append((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
        Factors.append(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">return</span> Forces, Factors
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>2...3</td>
<td>Create lists to hold both <i>Forces</i> and <i>Factors</i>.
</td>
</tr>
<tr>
<td>5...7</td>
<td>Iterate through both lists and assign default values (a zero-length vector in the case of <i>Forces</i> and zero in the case of <i>Factors</i>)
</td>
</tr>
<tr>
<td>9</td>
<td>Note that we are returning two separate items. The assignment in the line calling this function will contain both of these. Ways of handling this assignment will be handled later in the text.</td>
</tr>
</tbody></table>

<p>We’ve now dealt with all the utility functions. I know it’s a bit annoying to deal with code which has no obvious meaning yet, and at the risk of badgering you even more I’m going to take a step back and talk some more about the error diffusion algorithm we’ve come up with. For one, I’d like you to truly understand the logic behind it and I also need to deal with one last problem…</p>

<p>If we were to truly move each control point based directly on the inverse of its distance to {P’}, the hyperbolic diffusion decay of the sample points would be very noticeable in the final surface. Let’s take a look at a simple case, a planar surface {Base} which has to be fitted to four points {A; B; C; D}. Three of these points are above the surface (positive distance), one is below the surface (negative distance):</p>

<p><img src="./8 Geometry with Python_files/primer-hyperbolas.svg" class="img-center" width="100%"></p>

<p>On the left you see the four individual hyperbolas (one for each of the sample points) and on the right you see the result of a fitting operation which uses the hyperbola values directly to control control-point motion. Actually, the hyperbolas aren’t drawn to scale, in reality they are much <em>(much)</em> thinner, but drawing them to scale would make them almost invisible since they would closely hug the horizontal and vertical lines.</p>

<p>We see that the control points that are close to the projections of {A; B; C; D} on {Base} will be moved a great deal (such as {S}), whereas points in between (such as {T}) will hardly be moved at all. Sometimes this is useful behaviour, especially if we assume our original surface is already very close to the sample points. If this is not the case (like in the diagram above) then we end up with a flat surface with some very sharp tentacles poking out.</p>

<p>Lets assume our input surface is not already ‘almost’ good. This means that our algorithm cannot depend on the initial shape of the surface which in turn means that moving control points small amounts is not an option. We need to move all control points as far as necessary. This sounds very difficult, but the mathematical trick is a simple one. I won’t provide you with a proof of why it works, but what we need to do is divide the length of the motion vector by the value of the sum of all the hyperbolas.</p>

<p>Have a close look at control points {S} and {T} in the illustration above. {S} has a very high diffusion factor (lots of yellow above it) whereas {T} has a low diffusion factor (thin slivers of all colors on both sides). But if we want to move both {S} and {T} substantial amounts, we need to somehow boost the length of the motion vector for {T}. If you divide the motion vector by the value of the added hyperbolas, you sort of ‘unitize’ all the motion vectors, resulting in the following section:</p>

<p><img src="./8 Geometry with Python_files/primer-multisamplefitter-algorithm2.svg" class="img-center" width="60%"></p>

<p>which is a much smoother fit. The sag between {B} and {C} is not due to the shape of the original surface, but because between {B} and {C}, the other samples start to gain more relative influence and dragging the surface down towards them. Let’s have a look at the code:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FitSurface</span><span class="hljs-params">(idSrf, Samples, dTranslation, dProximity)</span>:</span>
    P = rs.SurfacePoints(idSrf)
    G = rs.SurfaceEditPoints(idSrf, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    N = GrevilleNormals(idSrf)
    S = ConvertToUVW(idSrf, Samples)
    [Forces, Factors] = InstantiateForceLists(len(P))

    dProximity = <span class="hljs-number">0.0</span>
    dTranslation = <span class="hljs-number">0.0</span>

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(S)):
        dProximity = dProximity + abs(S[i][<span class="hljs-number">2</span>])
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(P)):
            LocalDist = math.pow((S[i][<span class="hljs-number">0</span>] - G[j][<span class="hljs-number">0</span>]),<span class="hljs-number">2</span>) +  math.pow((S[i][<span class="hljs-number">1</span>] - G[j][<span class="hljs-number">1</span>]),<span class="hljs-number">2</span>)
            <span class="hljs-keyword">if</span> (LocalDist &lt; <span class="hljs-number">0.01</span>): LocalDist = <span class="hljs-number">0.01</span>
            LocalFactor = <span class="hljs-number">1</span> / LocalDist
            LocalForce = rs.VectorScale(N[j], LocalFactor * S[i][<span class="hljs-number">2</span>])
            Forces[j] = rs.VectorAdd(Forces[j], LocalForce)
            Factors[j] = Factors[j] + LocalFactor
    Forces = DivideVectorList(Forces, Factors)

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(P)):
        P[i] = rs.PointAdd(P[i], Forces[i])
        dTranslation = dTranslation + rs.VectorLength(Forces[i])

    srf_N = rs.SurfacePointCount(idSrf)
    srf_K = rs.SurfaceKnots(idSrf)
    srf_W = rs.SurfaceWeights(idSrf)
    srf_D = []
    srf_D.append(rs.SurfaceDegree(idSrf, <span class="hljs-number">0</span>))
    srf_D.append(rs.SurfaceDegree(idSrf, <span class="hljs-number">1</span>))

    FS = rs.AddNurbsSurface(srf_N, P, srf_K[<span class="hljs-number">0</span>], srf_K[<span class="hljs-number">1</span>], srf_D, srf_W)
    <span class="hljs-keyword">return</span> (FS, Samples, dTranslation, dProximity)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>This is another example of a function which returns more than one value. When this function completes, <i>dTranslation</i> will contain a number that represents the total motion of all control points and <i>dProximity</i> will contain the total error (the sum of all distances between the surface and the samples). Since it is unlikely our algorithm will generate a perfect fit right away, we somehow need to keep track of how effective a certain iteration is. If it turns out that the function only moved the control points a tiny bit, we can abort in the knowledge we have achieved a high level of accuracy.
</td>
</tr>
<tr>
<td>2...57</td>
<td><i>P, G, N</i> and <i>S</i> are lists that contain the surface control points (in {xyz} space), Greville points (in {uv} space), normal vectors at every greville point and all the sample coordinates (in {uvw} space). The names chosen can be difficult to remember, but they are short.
</td>
</tr>
<tr>
<td>6</td>
<td>The function we're calling here has been dealt with on page 104.</td>
</tr>
<tr>
<td>11</td>
<td>First, we iterate over all Sample points.</td>
</tr><tr>
<td>13</td>
<td>Then, we iterate over all Control points.</td>
</tr><tr>
<td>14</td>
<td><i>LocalDist</i> is the distance in {uv} space between the projection of the current sample point and the current Greville point.</td>
</tr><tr>
<td>15</td>
<td>This is where we limit the distance to some non-zero value in order to prevent extremely small numbers from entering the algorithmic meat-grinder.</td>
</tr><tr>
<td>16</td>
<td>Run the <i>LocalDist</i> through the hyperbola equation in order to get the diffusion factor for the current Control point and the current sample point.</td>
</tr><tr>
<td>17</td>
<td><i>LocalForce</i> is a vector which temporarily caches the motion caused by the current Sample point. This vector points in the same direction as the normal, but the magnitude (length) of the vector is the size of the error times the diffusion factor we've calculated on line 22.</td>
</tr>
<tr>
<td>18</td>
<td>Every Control point is affected by all Sample points, meaning that every Control point is tugged in a number of different directions. We need to combine all these forces so we end up with a final, resulting force. Because we're only interested in the final vector, we can simply add the vectors together as we calculate them.</td>
</tr>
<tr>
<td>19</td>
<td>We also need to keep a record of all the Diffusion factors along with all vectors, so we can divide them later and unitize the motion (as discussed on page 105).</td>
</tr>
<tr>
<td>20</td>
<td>Divide all vectors with all factors (function explained on page 104)</td>
</tr>
<tr>
<td>22...24</td>
<td>Apply the motion we've calculated to the {xyz} coordinates of the surface control points.</td>
</tr>
<tr>
<td>26...33</td>
<td>Instead of changing the existing surface, we're going to add a brand new one. In order to do this, we need to collect all the NURBS data of the original such as knot vectors, degrees, weights and so on and so forth.</td>
</tr>
</tbody></table>

<p>The procedure on the previous page has no interface code, thus it is not a top-level procedure. We need something that asks the user for a surface, some points and then runs the FitSurface() function a number of times until the fitting is good enough:</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DistributedSurfaceFitter</span><span class="hljs-params">()</span>:</span>
    idSrf = rs.GetObject(<span class="hljs-string">"Surface to fit"</span>, <span class="hljs-number">8</span>, <span class="hljs-keyword">True</span>, <span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">if</span> idSrf <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span>

    pts = rs.GetPointCoordinates(<span class="hljs-string">"Points to fit to"</span>, <span class="hljs-keyword">False</span>)
    <span class="hljs-keyword">if</span> pts <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span>

    dTrans = <span class="hljs-number">0</span>
    dProx = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> N <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>):
        rs.EnableRedraw(<span class="hljs-keyword">False</span>)
        nSrf, pts, dTrans, dProx = FitSurface(idSrf, pts, dTrans, dProx)
        rs.DeleteObject(idSrf)
        rs.EnableRedraw(<span class="hljs-keyword">True</span>)
        rs.Prompt(<span class="hljs-string">"Translation ="</span> + str(round(dTrans, <span class="hljs-number">2</span>)) + <span class="hljs-string">"Deviation ="</span> + str(round(dProx, <span class="hljs-number">2</span>)))
        <span class="hljs-keyword">if</span> dTrans &lt; <span class="hljs-number">0.1</span> <span class="hljs-keyword">or</span> dProx &lt; <span class="hljs-number">0.01</span>: <span class="hljs-keyword">break</span>
        idSrf = nSrf

    print(<span class="hljs-string">"Final deviation = "</span> + str(round(dProx, <span class="hljs-number">4</span>)))
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>11</td>
<td>Rather than using an infinite loop (<i>while</i>) we limit the total amount of fitting iterations to one thousand. That should be more than enough, and if we still haven't found a good solution by then it is unlikely we ever will. The variable N is known as a "chicken int" in coding slang. "Int" is short for "Integer" and "chicken" is because you're scared the loop might go on forever.
</td>
</tr>
<tr>
<td>12...15</td>
<td>Disable the viewport, create a new surface, delete the old one and switch the redraw back on
</td>
</tr>
<tr>
<td>16</td>
<td>Inform the user about the efficiency of the current iteration</td>
</tr>
<tr>
<td>17</td>
<td>If the total translation is negligible, we might as well abort since nothing we can do will make it any better. If the total error is minimal, we have a good fit and we should abort.</td>
</tr>
</tbody></table>

<p>The diagrams and graphs I’ve used so far to illustrate the workings of this algorithm are all two-dimensional and display only simplified cases. The images on this page show the progression of a single solution in 3D space. I’ve started with a planar, rectangular nurbs patch of 30 × 30 control points and 36 points both below and above the initial surface. I allowed the algorithm to continue refining until the total deviation was less than 0.01 units.</p>

<p><img src="./8 Geometry with Python_files/primer-iterations.svg" class="img-center" width="100%"></p>

<h3 id="892-surface-curvature">8.9.2 Surface Curvature</h3>

<p><img src="./8 Geometry with Python_files/primer-curvecurvaturelogic2.svg" alt="/images/primer-curvecurvaturelogic2.svg" class="float-img-right" width="325"></p>

<p>Curve curvature is easy to grasp intuitively. You simply fit a circle to a short piece of curve as best you can (this is called an osculating circle) and the radius and center of this circle tell you all you need to know about the local curvature. We’ve dealt with this already before.</p>

<p>Points {A; B; C; D; E} have a certain curvature associated with them. The radius of the respective circles is a measure for the curvature (in fact, the curvature is the inverse of the radius), and the direction of the vectors is an indication of the curve plane.</p>

<p>If we were to scale the curve to 50% of its original size the curvature circles also become half as big, effectively doubling the curvature values. Point {C} is special in that it has zero-curvature (i.e. the radius of the osculating circle is infinite). Points where the curvature value changes from negative to positive are known as inflection points. If we have multiple inflection points adjacent to each other, we are dealing with a linear segment in the curve.</p>

<p>Surface curvature is not so straightforward. For one, there are multiple definitions of curvature in the case of surfaces and volumes which one suits us best depends on our particular algorithm. Curvature is quite an important concept in many manufacturing and design projects, which is why I’ll deal with it in some depth. I won’t be dealing with any script code until the next section, so if you are already familiar with curvature theory feel free to skip ahead to page 111.</p>

<p>The most obvious way of evaluating surface curvature would be to slice it with a straight section through the point {P} we are interested in and then simply revert to curve curvature algorithms. But, as mentioned before, surfaces lack direction and it is thus not at all clear at which angle we should dissect the surface (we could use {u} and {v} directions, but those will not necessarily give you meaningful answers). Still, this approach is useful every now and again and it goes under the name of normal curvature. As you can see in the illustration below, there are an infinite number of sections through point {P} and thus an infinite number of answers to the question “what is the normal curvature at {P}?”</p>

<p><img src="./8 Geometry with Python_files/primer-curvatures.svg" class="img-center" width="100%"></p>

<p>However, under typical circumstances there is only one answer to the question: “what is the highest normal curvature at {P}?”. When you look at the complete set of all possible normal curvatures, you’ll find that the surface is mostly flat in one direction and mostly bent in another. These two directions are therefore special and they constitute the principal curvatures of a surface. The two principal curvature directions are always perpendicular to each other and thus they are completely independent of {u} and {v} directions ({u} and {v} are not necessarily perpendicular).</p>

<p>Actually, things are more complicated since there might be multiple directions which yield lowest or highest normal curvature so there’s a bit of additional magic required to get a result at all in some cases. Spheres for example have the same curvature in all directions so we cannot define principal curvature directions at all.</p>

<p>This is not the end of the story. Starting with the set of all normal curvatures, we extracted definitions of the principal curvatures. Principal curvatures always come in pairs (minimum and maximum) and they are both values and directions. We are more often than not only interested in how much a surface bends, not particularly in which direction. One of the reasons for this is that the progression of principal curvature directions across the surface is not very smooth:</p>

<p><img src="./8 Geometry with Python_files/primer-surfacek-tensor-field.svg" class="img-center" width="80%"></p>

<p>The illustration on the left shows the directions of the maximum principal curvatures. As you can see there are threshold lines on the surface at which the principal direction suddenly makes 90º turns. The overall picture is chaotic and overly complex. We can use a standard tensor-smoothing algorithm to average each direction with its neighbours, resulting in the image on the right, which provides us with an already much more useful distribution (e.g. for texturing or patterning purposes), but now the vectors have lost their meaning. This is why the principal curvature directions are not a very useful surface property in every day life.</p>

<p>Instead of dealing with the directions, the other aforementioned surface curvature definitions deal only with the scalar values of the curvature; the osculating circle radius. The most famous among surface curvature definitions are the Gaussian and Mean curvatures. Both of these are available in the _CurvatureAnalysis command and through RhinoScriptSyntax.</p>

<p>The great German mathematician Carl Friedrich Gauss figured out that by multiplying the principal curvature radii you get another, for some purposes much more useful indicator of curvature:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-26-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;&amp;#x22C5;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-352" style="width: 11.529em; display: inline-block;"><span style="display: inline-block; position: relative; width: 9.429em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(1.386em, 1009.43em, 2.513em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-353"><span class="msubsup" id="MathJax-Span-354"><span style="display: inline-block; position: relative; width: 2.923em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-355" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="texatom" id="MathJax-Span-356"><span class="mrow" id="MathJax-Span-357"><span class="mi" id="MathJax-Span-358" style="font-size: 70.7%; font-family: MathJax_Math-italic;">G</span><span class="mi" id="MathJax-Span-359" style="font-size: 70.7%; font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-360" style="font-size: 70.7%; font-family: MathJax_Math-italic;">u</span><span class="mi" id="MathJax-Span-361" style="font-size: 70.7%; font-family: MathJax_Math-italic;">s</span><span class="mi" id="MathJax-Span-362" style="font-size: 70.7%; font-family: MathJax_Math-italic;">s</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-363" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="msubsup" id="MathJax-Span-364" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 2.205em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-365" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="texatom" id="MathJax-Span-366"><span class="mrow" id="MathJax-Span-367"><span class="mi" id="MathJax-Span-368" style="font-size: 70.7%; font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-369" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-370" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-371" style="font-family: MathJax_Main; padding-left: 0.207em;">⋅</span><span class="msubsup" id="MathJax-Span-372" style="padding-left: 0.207em;"><span style="display: inline-block; position: relative; width: 2.308em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-373" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="texatom" id="MathJax-Span-374"><span class="mrow" id="MathJax-Span-375"><span class="mi" id="MathJax-Span-376" style="font-size: 70.7%; font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-377" style="font-size: 70.7%; font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-378" style="font-size: 70.7%; font-family: MathJax_Math-italic;">x</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.191em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>G</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>⋅</mo><msub><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-26">K_{Gauss}=K_{min} \cdot K_{max}</script>

<p>Where J<sub>Gauss</sub> is the Gaussian curvature and l<sub>min</sub> and l<sub>max</sub> are the principal curvatures. Assuming you are completely comfortable with the behaviour of multiplications, we can identify a number of specific cases:</p>

<p><img src="./8 Geometry with Python_files/primer-curvature-directions.svg" class="img-center" width="100%"></p>

<p>From this we can conclude that any surface which has zero Gaussian curvature everywhere can be unrolled into a flat sheet and any surface with negative Gaussian curvature everywhere can be made by stretching elastic cloth.</p>

<p>The other important curvature definition is Mean curvature (“average”), which is essentially the sum of the principal curvatures:</p>

<span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_Display" style="text-align: center;"><span class="MathJax" id="MathJax-Element-27-Frame" tabindex="0" style="text-align: center; position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;K&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-379" style="width: 12.4em; display: inline-block;"><span style="display: inline-block; position: relative; width: 10.146em; height: 0px; font-size: 122%;"><span style="position: absolute; clip: rect(0.669em, 1010.15em, 3.025em, -999.997em); top: -2.2em; left: 0em;"><span class="mrow" id="MathJax-Span-380"><span class="msubsup" id="MathJax-Span-381"><span style="display: inline-block; position: relative; width: 2.82em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-382" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="texatom" id="MathJax-Span-383"><span class="mrow" id="MathJax-Span-384"><span class="mi" id="MathJax-Span-385" style="font-size: 70.7%; font-family: MathJax_Math-italic;">M<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span class="mi" id="MathJax-Span-386" style="font-size: 70.7%; font-family: MathJax_Math-italic;">e</span><span class="mi" id="MathJax-Span-387" style="font-size: 70.7%; font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-388" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-389" style="font-family: MathJax_Main; padding-left: 0.259em;">=</span><span class="mfrac" id="MathJax-Span-390" style="padding-left: 0.259em;"><span style="display: inline-block; position: relative; width: 5.843em; height: 0px; margin-right: 0.105em; margin-left: 0.105em;"><span style="position: absolute; clip: rect(3.179em, 1005.74em, 4.306em, -999.997em); top: -4.659em; left: 50%; margin-left: -2.866em;"><span class="mrow" id="MathJax-Span-391"><span class="msubsup" id="MathJax-Span-392"><span style="display: inline-block; position: relative; width: 2.205em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-393" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="texatom" id="MathJax-Span-394"><span class="mrow" id="MathJax-Span-395"><span class="mi" id="MathJax-Span-396" style="font-size: 70.7%; font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-397" style="font-size: 70.7%; font-family: MathJax_Math-italic;">i</span><span class="mi" id="MathJax-Span-398" style="font-size: 70.7%; font-family: MathJax_Math-italic;">n</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span><span class="mo" id="MathJax-Span-399" style="font-family: MathJax_Main; padding-left: 0.207em;">+</span><span class="msubsup" id="MathJax-Span-400" style="padding-left: 0.207em;"><span style="display: inline-block; position: relative; width: 2.308em; height: 0px;"><span style="position: absolute; clip: rect(3.179em, 1000.87em, 4.152em, -999.997em); top: -3.993em; left: 0em;"><span class="mi" id="MathJax-Span-401" style="font-family: MathJax_Math-italic;">K<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.054em;"></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; top: -3.84em; left: 0.873em;"><span class="texatom" id="MathJax-Span-402"><span class="mrow" id="MathJax-Span-403"><span class="mi" id="MathJax-Span-404" style="font-size: 70.7%; font-family: MathJax_Math-italic;">m</span><span class="mi" id="MathJax-Span-405" style="font-size: 70.7%; font-family: MathJax_Math-italic;">a</span><span class="mi" id="MathJax-Span-406" style="font-size: 70.7%; font-family: MathJax_Math-italic;">x</span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(3.179em, 1000.46em, 4.152em, -999.997em); top: -3.327em; left: 50%; margin-left: -0.254em;"><span class="mn" id="MathJax-Span-407" style="font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(0.873em, 1005.84em, 1.232em, -999.997em); top: -1.278em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 5.843em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.078em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.205em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.628em;"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>M</mi><mi>e</mi><mi>a</mi><mi>n</mi></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>K</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><mn>2</mn></mfrac></math></span></span></div><script type="math/tex; mode=display" id="MathJax-Element-27">K_{Mean}=\frac{K_{min} + K_{max}}{2}</script>

<p>As you know, summation behaves very different from multiplication, and Mean curvature can be used to analyze different properties of a surface because it has different special cases. If the minimum and maximum principal curvatures are equal in amplitude but have opposing signs, the average of both is zero. A surface with zero Mean curvature is not merely anticlastic, it is a very special surface known as a <em>minimal</em> or <em>zero-energy</em> surface. It is the natural shape of a soap film with equal atmospheric pressure on both sides. These surfaces are extremely important in the field of tensile architecture since they spread stress equally across the surface resulting in structurally strong geometry.</p>

<h3 id="893-vector-and-tensor-spaces">8.9.3 Vector and Tensor spaces</h3>

<p>On the previous page I mentioned the words “tensor”, “smoothing” and “algorithm” in one breath. Even though you most likely know the latter two, the combination probably makes little sense. Tensor smoothing is a useful tool to have in your repertoire so I’ll deal with this specific case in detail. Just remember that most of the script which is to follow is generic and can be easily adjusted for different classes of tensors. But first some background information…</p>

<p>Imagine a surface with no singularities and no stacked control points, such as a torus or a plane. Every point on this surface has a normal vector associated with it. The collection of all these vectors is an example of a vector space. A vector space is a continuous set of vectors over some interval. The set of all surface normals is a two-dimensional vector space (sometimes referred to as a vector field), just as the set of all curve tangents is a one-dimensional vector space, the set of all air-pressure components in a turbulent volume over time is a four-dimensional vector space and so on and so forth.</p>

<p>When we say “vector”, we usually mean little arrows; a list of numbers that indicate a direction and a magnitude in some sort of spatial context. When things get more complicated, we start using “tensor” instead. Tensor is a more general term which has fewer connotations and is thus preferred in many scientific texts.</p>

<p><img src="./8 Geometry with Python_files/primer-tensorspace2.svg" alt="/images/primer-tensorspace2.svg" class="float-img-right" width="375"></p>

<p>For example, the surface of your body is a two-dimensional tensor space (embedded in four dimensional space-time) which has many properties that vary smoothly from place to place; hairiness, pigmentation, wetness, sensitivity, freckliness and smelliness to name just a few. If we measure all of these properties in a number of places, we can make educated guesses about all the other spots on your body using interpolation and extrapolation algorithms. We could even make a graphical representation of such a tensor space by using some arbitrary set of symbols.</p>

<p>We could visualize the wetness of any piece of skin by linking it to the amount of blue in the colour of a box, and we could link freckliness to green, or to the width of the box, or to the rotational angle.</p>

<p>All of these properties together make up the tensor class. Since we can pick and choose whatever we include and ignore, a tensor is essentially whatever you want it to be. Let’s have a more detailed look at the tensor class mentioned on the previous page, which is a rather simple one…</p>

<p>I created a vector field of maximum-principal curvature directions over the surface (sampled at a certain custom resolution), and then I smoothed them out in order to get rid of the sudden jumps in direction. Averaging two vectors is easy, but averaging them while keeping the result tangent to a surface is a bit harder.</p>

<p>In this particular case we end up with a two-dimensional tensor space, where the tensor class T consist of a vector and a tangent plane:</p>

<p><img src="./8 Geometry with Python_files/primer-tensormatrixes.svg" class="img-center" width="75%"></p>

<p>Since we’re sampling the surface at regular parameter intervals in {u} and {v} directions, we end up with a matrix of tensors (a table of rows and columns). We can represent this easily with a two-dimensional list. We’ll need two of these in our script since we need to store two separate data-entities; vectors and planes.</p>

<p><img src="./8 Geometry with Python_files/primer-smoothing.svg" class="img-center" width="100%"></p>

<p>This progression of smoothing iterations clearly demonstrates the usefulness of a tensor-smoothing algorithm; it helps you to get rid of singularities and creases in any continuous tensor space.</p>

<p>I’m not going to spell the entire script out here, I’ll only highlight the key functions. You can find the complete script (including comments) in the Script folder.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SurfaceTensorField</span><span class="hljs-params">(Nu, Nv)</span>:</span>
    idSrf = rs.GetSurfaceObject()[<span class="hljs-number">0</span>]
    uDomain = rs.SurfaceDomain(idSrf, <span class="hljs-number">0</span>)
    vDomain = rs.SurfaceDomain(idSrf, <span class="hljs-number">1</span>)

    T = []
    K = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(Nu):
        T.append([])
        K.append([])
        u = uDomain[<span class="hljs-number">0</span>] + (i/Nu)*(uDomain[<span class="hljs-number">1</span>] - uDomain[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span>  range(Nv):
            v = vDomain[<span class="hljs-number">0</span>] + (j/Nv)*(vDomain[<span class="hljs-number">1</span>] - vDomain[<span class="hljs-number">0</span>])
            T[i].append(rs.SurfaceFrame(idSrf,(u,v)))
            localCurvature = rs.SurfaceCurvature(idSrf,(u,v))
            <span class="hljs-keyword">if</span> localCurvature <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
                K[i].append(T[i][j][<span class="hljs-number">1</span>])
            <span class="hljs-keyword">else</span>:
                K[i].append(rs.SurfaceCurvature(idSrf,(u,v))[<span class="hljs-number">3</span>])
    <span class="hljs-keyword">return</span> SmoothTensorField(T,K)
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>This procedure has to create all the lists that define our tensor class. In this case one list with vectors and a list with planes.
</td>
</tr>
<tr>
<td>9...10</td>
<td>At the beginning of each iteration down the range <i>N<sub>u</sub></i>, we nest a new list in both T and K, which will hold all values of iterations of the range <i>N<sub>v</sub></i>.
</td>
</tr>
<tr>
<td>11</td>
<td>This looks imposing, but it is a very standard piece of logic. The problem here is a common one: how to remap a number from one scale to another. We know how many samples the user wants (some whole number) and we know the limits of the surface domain (two doubles of some arbitrary value). We need to figure out which parameter on the surface domain matches with the Nth sample number. Observe the diagram below for a schematic representation of the problem:
<br>
<img src="./8 Geometry with Python_files/primer-remapnumberscales.svg" width="80%" float="right">
<br>
Our sample count (the topmost bar) goes from {A} to {B}, and the surface domain includes all values between {C} and {D}. We need to figure out how to map numbers in the range {A~B} to the range {C~D}. In our case we need a linear mapping function meaning that the value halfway between {A} and {B} gets remapped to another value halfway between {C} and {D}.
<br><br>
Line 11 (and line 13) contain an implementation of such a mapping algorithm. I'm not going to spell out exactly how it works, if you want to fully understand this script you'll have to look into that by yourself.
</td>
</tr>
<tr>
<td>14</td>
<td>Retrieve the surface Frame at {u,v}. This is part of our Tensor class.</td>
</tr>
<tr>
<td>15</td>
<td>Retrieve all surface curvature information at {u,v}. This includes principal, mean and Gaussian curvature values and vectors.</td>
</tr><tr>
<td>17</td>
<td>In case the surface has no curvature at {u,v}, use the x-axis vector of the Frame instead.</td>
</tr><tr>
<td>19</td>
<td>If the surface has a valid curvature at {u,v}, we can use the principal curvature direction which is stored in the 4th element of the curvature data array.</td>
</tr></tbody></table>

<p>This function takes two lists and it modifies the originals. The return value (the two lists) is merely cosmetic. This function is a typical box-blur algorithm. It averages the values in every tensor with all neighboring tensors using a 3×3 blur matrix.</p>

<pre class="line-numbers"><code class="hljs hljs-line-numbers" style="float: left;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</code><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SmoothTensorField</span><span class="hljs-params">(T, K)</span>:</span>
    SmoothTensorField = <span class="hljs-keyword">False</span>
    Ub1 = len(T[<span class="hljs-number">1</span>])
    Ub2 = len(T[<span class="hljs-number">2</span>])
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(Ub1):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(Ub2):
            k_tot = (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(i<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>):
                xm = (x+Ub1) % Ub1
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(j<span class="hljs-number">-1</span>, j+<span class="hljs-number">1</span>):
                    ym = (y+Ub2) % Ub2
                    k_tot = rs.VectorAdd(k_tot, K[xm][ym])
            k_dir = rs.PlaneClosestPoint(T[i][j], rs.VectorAdd(T[i][j][<span class="hljs-number">0</span>], k_tot))
            k_tot = rs.VectorSubtract(k_dir, T[i][j][<span class="hljs-number">0</span>])
            k_tot = rs.VectorUnitize(k_tot)
            K[i].append(k_tot)
            rs.AddLine(T[i][j][<span class="hljs-number">0</span>],T[i][j][<span class="hljs-number">0</span>]+K[i][j])
    <span class="hljs-keyword">return</span> T, K
</code></pre>

<table class="multiline">
<tbody><tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>5...6</td>
<td>Since our tensor-space is two-dimensional, we need 2 nested loops to iterate over the entire set.
</td>
</tr>
<tr>
<td>8...11</td>
<td>
<table>
<tbody><tr>
<td>
Now that we're dealing with each tensor individually (the first two loops) we need to deal with each tensors neighbours as well (the second set of nested loops). We can visualize the problem at hand with a simple table graph.
<br><br>
The green area is a corner of the entire two-dimensional tensor space, the dark green lines delineating each individual tensor. The dark grey square is the tensor we're currently working on. It is located at {u,v}. The eight white squares around it are the adjacent tensors which will be used to blur the tensor at {u,v}.
<br><br>
We need to make 2 more nested loops which iterate over the 9 coordinates in this 3×3 matrix. We also need to make sure that all these 9 coordinates are in fact on the 2D tensor space and not teetering over the edge. We can use the Mod operator to make sure a number is "remapped" to belong to a certain numeric domain.
</td>
<td width="40%"><img src="./8 Geometry with Python_files/primer-boxblurmatrix3x3.svg" width="100%" height="300" float="right"></td>
</tr>
</tbody></table>

</td>
</tr>
<tr>
<td>12</td>
<td>Once we have the <i>mx</i> and <i>my</i> coordinates of the tensor, we can add it to the <i>k_tot</i> summation vector.
</td>
</tr>
<tr>
<td>13...16</td>
<td>Make sure the vector is projected back onto the tangent plane and unitized.</td>
</tr>
</tbody></table>

<hr>

<h2 id="next-steps">Next Steps</h2>

<p>Congratulations, you have made it through the Python 101 Primer.</p>

        </article>

      <!--</div>-->

    </div>
</div>
</div>

        <!--/div-->
      </div>

      <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">

      
        <div class="row">
          <div class="col-md-4">

            <p class="text">
              
                Authors:
                </p><ul>
                  
                  
                    
                    <li><a href="https://developer.rhino3d.com/authors/skylar_tibbits">Skylar Tibbits</a></li>
                  
                    
                    <li><a href="https://developer.rhino3d.com/authors/arthur_van_der_harten">Arthur van der Harten</a></li>
                  
                    
                    <li><a href="https://developer.rhino3d.com/authors/steve_baer">Steve Baer</a></li>
                  
                </ul>
              
            <p></p>
          </div>
          <div class="col-md-4 text-center">
            <span class="icon  icon--github">
              <svg viewBox="0 0 16 16">
                <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
              </svg>
            </span>
            <a href="https://github.com/mcneel/developer-rhino3d-com/blob/6/_guide_topics/rhinopython/primer-101/8-geometry.md" target="_blank">Edit page on GitHub</a>
          </div>
            <div class="col-md-4">
              <span class="pull-right">
                <span class="glyphicon glyphicon-cog"></span>&nbsp;<a href="https://developer.rhino3d.com/admin">Admin</a>
              </span>
            </div>
        </div>

        <div class="row text-center">
          © 1997 - 2020 Robert McNeel &amp; Associates<br>
          <span class="glyphicon glyphicon-heart-empty"></span>&nbsp;<a href="https://developer.rhino3d.com/authors">Contributions welcome</a>
        </div>

      

    </div>

  </div>

  <script>
    if (navigator.appVersion.indexOf("Win")!=-1)
    {
      var body = document.getElementsByTagName("body");
      body[0].style.fontWeight = '400';
    }
  </script>

</footer>

    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="./8 Geometry with Python_files/jquery.min(1).js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="./8 Geometry with Python_files/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <!-- MathJax -->
    <script type="text/javascript" src="./8 Geometry with Python_files/MathJax.js"></script>

    <script type="text/javascript">
    $('body').scrollspy({
        target: '.bs-docs-sidebar',
        offset: 150 /* fixed header is about 40px high */
    });
    </script>
  

<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Size2, sans-serif;"></div></div></body></html>